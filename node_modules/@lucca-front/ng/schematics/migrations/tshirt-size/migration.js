"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.migrateTsFile = exports.migrateHTMLFile = exports.migrateScssFile = void 0;
const typescript_1 = require("typescript");
const angular_template_1 = require("../../lib/angular-template");
const file_update_js_1 = require("../../lib/file-update.js");
const html_ast_js_1 = require("../../lib/html-ast.js");
const scss_ast_js_1 = require("../../lib/scss-ast.js");
const mapping_1 = require("./mapping");
function migrateScssFile(content, postCssScss, postcssValueParser, postcssSelectorParser) {
    const root = postCssScss.parse(content);
    (0, scss_ast_js_1.updateMixinNames)(root, mapping_1.mixinMapping);
    (0, scss_ast_js_1.updateCSSVariableNames)(root, mapping_1.cssVariableMapping, postcssValueParser);
    (0, scss_ast_js_1.updateCSSClassNamesInRules)(root, mapping_1.cssClassMapping, postcssSelectorParser);
    root.walkAtRules(/(import|use|forward)/, (rule) => {
        (0, scss_ast_js_1.removeImportNode)(rule, '@lucca-front/scss/src/components/skipLinks', postcssValueParser);
    });
    return root.toResult({ syntax: { stringify: postCssScss.stringify } }).css;
}
exports.migrateScssFile = migrateScssFile;
function migrateHTMLFile(content, angularCompiler) {
    return (0, html_ast_js_1.updateCssClassNames)(content, mapping_1.cssClassMapping, angularCompiler);
}
exports.migrateHTMLFile = migrateHTMLFile;
function migrateTsFile(fileName, content, angularCompiler) {
    const sourcefile = (0, typescript_1.createSourceFile)(fileName, content, typescript_1.ScriptTarget.ESNext);
    const templates = (0, angular_template_1.extractNgTemplates)(sourcefile);
    const updates = templates.map((tpl) => ({
        position: tpl.offsetStart,
        oldContent: tpl.content,
        newContent: (0, html_ast_js_1.updateCssClassNames)(tpl.content, mapping_1.cssClassMapping, angularCompiler),
    }));
    (0, typescript_1.forEachChild)(sourcefile, (0, angular_template_1.createVisitor)(typescript_1.isStringLiteral, (node) => {
        let newText = node.text;
        const withoutClass = node.text.replace('class.', '');
        const withoutStyle = node.text.replace('style.', '');
        if (mapping_1.cssClassesToUpdate.has(node.text)) {
            newText = mapping_1.cssClassMapping[node.text];
        }
        else if (mapping_1.cssClassesToUpdate.has(withoutClass)) {
            newText = 'class.' + mapping_1.cssClassMapping[withoutClass];
        }
        else if (mapping_1.cssVarsToUpdate.has(node.text)) {
            newText = mapping_1.cssVariableMapping[node.text] || node.text;
        }
        else if (mapping_1.cssVarsToUpdate.has(withoutStyle)) {
            newText = 'style.' + mapping_1.cssVariableMapping[withoutStyle] || node.text;
        }
        if (newText !== node.text) {
            const position = node.pos + node.getLeadingTriviaWidth(sourcefile) /* Spaces before the single/double quote */ + 1; /* Single or double quote before the string content */
            updates.push({
                position,
                oldContent: node.text,
                newContent: newText,
            });
        }
    }));
    return (0, file_update_js_1.applyUpdates)(content, updates);
}
exports.migrateTsFile = migrateTsFile;
