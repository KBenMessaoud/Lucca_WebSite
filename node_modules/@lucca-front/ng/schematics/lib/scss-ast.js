"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.wrapWithCalcFunctionNode = exports.commentNode = exports.removeImportNode = exports.updateCSSVariableNames = exports.updateCSSClassNamesInRules = exports.updateMixinNames = exports.addForwardRule = exports.addImport = exports.addMixinImport = exports.removeContainerIfEmpty = void 0;
const scss_value_ast_js_1 = require("./scss-value-ast.js");
function removeContainerIfEmpty(node) {
    if (!node) {
        return;
    }
    if (!node.nodes.length) {
        const { parent } = node;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access
        const semicolon = node.raws.semicolon;
        const nextOrParentNode = node.next() || node.parent;
        node.remove();
        if (semicolon) {
            if (nextOrParentNode) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access
                nextOrParentNode.raws.semicolon = semicolon;
            }
        }
        if (!parent || parent.type === 'document') {
            return;
        }
        removeContainerIfEmpty(parent);
    }
}
exports.removeContainerIfEmpty = removeContainerIfEmpty;
function addMixinImport(root, mixin, postCss, namespace = '') {
    let lastImportRule;
    root.walkAtRules(/(import|use)/, (rule) => {
        lastImportRule = rule;
    });
    let importStr = `'${mixin}'`;
    if (namespace) {
        importStr += ` as ${namespace}`;
    }
    const newImportRule = new postCss.AtRule({ name: 'use', params: importStr });
    return addImport(root, newImportRule, lastImportRule);
}
exports.addMixinImport = addMixinImport;
function addImport(root, atRule, afterNode) {
    if (afterNode) {
        atRule.raws.before = '\n';
        afterNode.after(atRule);
    }
    else {
        const firstNode = root.first;
        if (firstNode) {
            root.first.before(atRule);
            firstNode.raws.before = '\n\n';
        }
        else {
            root.append(atRule);
        }
    }
    return atRule;
}
exports.addImport = addImport;
function addForwardRule(root, name, postCss, afterNode) {
    if (!afterNode) {
        root.walkAtRules('forward', (rule) => {
            afterNode = rule;
        });
    }
    if (!afterNode && root.first?.type === 'comment') {
        afterNode = root.first;
    }
    return addImport(root, new postCss.AtRule({ name: 'forward', params: `'${name}'` }), afterNode);
}
exports.addForwardRule = addForwardRule;
function updateMixinNames(root, mappingOldToNew) {
    root.walkAtRules('include', (rule) => {
        rule.params = mappingOldToNew[rule.params] || rule.params;
    });
}
exports.updateMixinNames = updateMixinNames;
function updateCSSClassNamesInRules(root, mappingOldToNew, postScssSelectorParser) {
    root.walkRules((rule) => {
        if (rule.selector.endsWith(':')) {
            /**
             * In sass we can do such a thing:
             * .foo {
             * 		padding: {
             * 			top: 10px;
             * 			bottom: 10px;
             * 		}
             * }
             * "padding:" is considered as a rule but its selector cannot be parsed using postScssSelectorParser
             */
            return;
        }
        const selector = postScssSelectorParser().astSync(rule.selector);
        selector.walkClasses((classNode) => {
            // Exclude interpolation and function calls
            if (classNode.value.includes('#{') || classNode.value.includes('(')) {
                return;
            }
            classNode.value = mappingOldToNew[classNode.value] || classNode.value;
        });
        rule.selector = selector.toString();
    });
}
exports.updateCSSClassNamesInRules = updateCSSClassNamesInRules;
function updateCSSVariableNames(root, mappingOldToNew, postcssValueParser) {
    root.walkDecls((decl) => {
        if (decl.prop.startsWith('--')) {
            decl.prop = mappingOldToNew[decl.prop] || decl.prop;
        }
        const valueNode = new scss_value_ast_js_1.ScssValueAst(decl.value, postcssValueParser);
        valueNode.walkFunction('var', (funcNode) => {
            const varName = funcNode.nodes[0]?.value ?? '';
            const newVarName = varName && mappingOldToNew[varName];
            if (newVarName) {
                funcNode.nodes = new scss_value_ast_js_1.ScssValueAst(newVarName, postcssValueParser).nodes;
            }
        });
        decl.value = valueNode.toString();
    });
    root.walkAtRules((decl) => {
        const paramsNode = new scss_value_ast_js_1.ScssValueAst(decl.params, postcssValueParser);
        paramsNode.walkFunction('var', (funcNode) => {
            const varName = funcNode.nodes[0]?.value ?? '';
            const newVarName = varName && mappingOldToNew[varName];
            if (newVarName) {
                funcNode.nodes = new scss_value_ast_js_1.ScssValueAst(newVarName, postcssValueParser).nodes;
            }
        });
        decl.params = paramsNode.toString();
    });
}
exports.updateCSSVariableNames = updateCSSVariableNames;
/**
 * @returns {boolean} returns true if whole node is deleted
 */
function removeImportNode(atRule, name, postcssValueParser) {
    if (atRule.params.includes(name)) {
        const parsed = new scss_value_ast_js_1.ScssValueAst(atRule.params, postcssValueParser);
        const imports = parsed.nodes.filter((n) => n.type === 'string');
        if (imports.length === 1) {
            // Remove the whole import
            atRule.remove();
            return true;
        }
        // Remove node matching condition
        parsed.nodes = parsed.nodes.filter((n) => n.type !== 'string' || !n.value.includes(name));
        // Remove first node if divider
        if (parsed.nodes[0]?.type === 'div') {
            parsed.nodes = parsed.nodes.slice(1);
        }
        // Remove last node if divider
        if (parsed.nodes[parsed.nodes.length - 1]?.type === 'div') {
            parsed.nodes = parsed.nodes.slice(0, -1);
        }
        // Remove consecutive divider nodes
        parsed.nodes = parsed.nodes.filter((n, index) => n.type !== 'div' || parsed.nodes[index + 1]?.type !== 'div');
        atRule.params = parsed.toString();
    }
    return false;
}
exports.removeImportNode = removeImportNode;
function commentNode(node, comment, postCss) {
    const commentNode = new postCss.Comment({ text: `[LF NEXT] ${comment}`, raws: { inline: true, right: '' } });
    const leadingSpaceOrigin = node.raws.before?.match(/ +/)?.[0].length ?? 0;
    const commentCodeNodes = node
        .toString()
        .split('\n')
        .map((text) => {
        const leadingSpaces = (text.match(/^ +/)?.[0] || '').slice(leadingSpaceOrigin) + ' ';
        return new postCss.Comment({ text: text.trim(), raws: { inline: true, right: '', left: leadingSpaces } });
    });
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const originalBefore = node.raws.before;
    node.replaceWith(commentNode, ...commentCodeNodes);
    commentNode.raws.before = originalBefore;
    commentCodeNodes[0].raws.before = commentCodeNodes[0].raws.before?.replace(/\n+/, '\n');
}
exports.commentNode = commentNode;
function wrapWithCalcFunctionNode(rootValueNode, node, postcssValueParser) {
    const parent = rootValueNode.getParent(node);
    if (parent?.type === 'function' && parent.value === 'calc') {
        return;
    }
    // Split function argument
    const { chunks, separators } = split(parent?.nodes ?? rootValueNode.nodes, (n) => n.type === 'div');
    const updated = chunks.map((block) => {
        // Wrap block inside a calc()
        return block.includes(node) ? new scss_value_ast_js_1.ScssValueAst(`calc(${rootValueNode.stringify(...block)})`, postcssValueParser).nodes : block;
    });
    const newNodes = join(updated, separators);
    if (parent) {
        parent.nodes = newNodes;
    }
    else {
        rootValueNode.nodes = newNodes;
    }
}
exports.wrapWithCalcFunctionNode = wrapWithCalcFunctionNode;
function split(array, predicate) {
    const chunks = [];
    const separators = [];
    let current = [];
    for (const item of array) {
        if (predicate(item)) {
            separators.push(item);
            chunks.push(current);
            current = [];
        }
        else {
            current.push(item);
        }
    }
    chunks.push(current);
    return { chunks, separators };
}
function join(array, separators) {
    return array.reduce((acc, chunk, index) => (index === 0 ? chunk : [...acc, separators[index - 1], ...chunk]), []);
}
