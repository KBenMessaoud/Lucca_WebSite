"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractAllHtmlElementNames = exports.extractAllCssClassNames = exports.updateCssClassNames = exports.HtmlAst = void 0;
const mapping_js_1 = require("../migrations/tshirt-size/mapping.js");
const file_update_js_1 = require("./file-update.js");
class HtmlAst {
    constructor(content, lib) {
        this.lib = lib;
        this.parsed = lib.parseTemplate(content, 'migration.html', { preserveWhitespaces: true });
    }
    visitElements(elementFilter, cb) {
        this.visitNodes((node) => {
            if (node instanceof this.lib.TmplAstElement) {
                if (this.matchFilter(node.name, elementFilter)) {
                    cb(node);
                }
            }
        });
    }
    visitAttribute(attributeFilter, cb) {
        this.visitNodes((node) => {
            if (node instanceof this.lib.TmplAstElement || node instanceof this.lib.TmplAstTemplate || node instanceof this.lib.TmplAstContent) {
                for (const attr of node.attributes) {
                    if (this.matchFilter(attr.name, attributeFilter)) {
                        cb(attr);
                    }
                }
            }
        });
    }
    visitBoundAttribute(attributeFilter, cb) {
        this.visitNodes((node) => {
            if (node instanceof this.lib.TmplAstElement || node instanceof this.lib.TmplAstTemplate) {
                for (const input of node.inputs) {
                    if (this.matchFilter(input.name, attributeFilter)) {
                        cb(input);
                    }
                }
            }
        });
    }
    visitNodes(cb) {
        this.visit(cb, this.parsed.nodes);
    }
    visit(cb, nodes) {
        for (const node of nodes) {
            cb(node);
            if (node instanceof this.lib.TmplAstElement || node instanceof this.lib.TmplAstTemplate) {
                this.visit(cb, node.children);
            }
        }
    }
    matchFilter(value, filter) {
        return typeof filter === 'string' ? value === filter : !!value.match(filter);
    }
}
exports.HtmlAst = HtmlAst;
function updateCssClassNames(content, oldClassToNewClass, lib) {
    const updates = [];
    const root = new HtmlAst(content, lib);
    const visitedAttributes = new Set();
    root.visitAttribute('class', (classAttr) => {
        const offset = classAttr.valueSpan?.start.offset;
        if (visitedAttributes.has(classAttr)) {
            return;
        }
        visitedAttributes.add(classAttr);
        const classes = classAttr.value.split(' ');
        if (classes.some((cl) => mapping_js_1.cssClassesToUpdate.has(cl)) && offset !== undefined) {
            updates.push({
                position: offset,
                oldContent: classAttr.value,
                newContent: classes.map((cl) => oldClassToNewClass[cl] || cl).join(' '),
            });
        }
    });
    root.visitBoundAttribute(/.*/, (boundAttr) => {
        if (visitedAttributes.has(boundAttr)) {
            return;
        }
        const cl = boundAttr.name;
        if (!mapping_js_1.cssClassesToUpdate.has(cl)) {
            return;
        }
        visitedAttributes.add(boundAttr);
        updates.push({
            position: boundAttr.keySpan.start.offset,
            oldContent: boundAttr.keySpan.details || '',
            newContent: boundAttr.keySpan.details?.replace(`class.${cl}`, `class.${oldClassToNewClass[cl]}`) || '',
        });
    });
    root.visitBoundAttribute('ngClass', (boundAttr) => {
        if (!(boundAttr.value instanceof lib.ASTWithSource)) {
            return;
        }
        if (visitedAttributes.has(boundAttr)) {
            return;
        }
        visitedAttributes.add(boundAttr);
        const { source } = boundAttr.value;
        const oldContent = boundAttr.value.source || '';
        const newContent = (source || '').replace(/(["']?)([\w\-_]*?)(["']?):/g, (_fullMatch, before, middle, after) => `${before + (oldClassToNewClass[middle] || middle) + after}:`);
        if (oldContent !== newContent) {
            updates.push({
                position: boundAttr.value.sourceSpan.start,
                oldContent,
                newContent,
            });
        }
    });
    return (0, file_update_js_1.applyUpdates)(content, updates);
}
exports.updateCssClassNames = updateCssClassNames;
function extractAllCssClassNames(content, lib) {
    const allClasses = new Set();
    const root = new HtmlAst(content, lib);
    root.visitAttribute('class', (classAttr) => classAttr.value.split(' ').forEach((cls) => allClasses.add(cls)));
    root.visitBoundAttribute(/.*/, (boundAttr) => {
        if (boundAttr.keySpan.details?.startsWith('class.')) {
            allClasses.add(boundAttr.name);
        }
    });
    return [...allClasses];
}
exports.extractAllCssClassNames = extractAllCssClassNames;
function extractAllHtmlElementNames(content, lib) {
    const allElements = new Set();
    const root = new HtmlAst(content, lib);
    root.visitElements(/.*/, (element) => allElements.add(element.name));
    return [...allElements];
}
exports.extractAllHtmlElementNames = extractAllHtmlElementNames;
