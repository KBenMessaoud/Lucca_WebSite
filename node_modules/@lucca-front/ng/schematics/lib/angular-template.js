"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createVisitor = exports.extractNgTemplates = void 0;
const typescript_1 = require("typescript");
function extractNgTemplates(fileNameOrSourceFile, content) {
    const sourcefile = typeof fileNameOrSourceFile === 'string' ? (0, typescript_1.createSourceFile)(fileNameOrSourceFile, content || '', typescript_1.ScriptTarget.ESNext) : fileNameOrSourceFile;
    const templates = [];
    (0, typescript_1.forEachChild)(sourcefile, createVisitor(typescript_1.isDecorator, (decorator) => {
        if (!(0, typescript_1.isCallExpression)(decorator.expression)) {
            return;
        }
        if (!(0, typescript_1.isIdentifier)(decorator.expression.expression)) {
            return;
        }
        if (decorator.expression.expression.escapedText !== 'Component') {
            return;
        }
        const argument = decorator.expression.arguments[0];
        if (!argument || !(0, typescript_1.isObjectLiteralExpression)(argument)) {
            return;
        }
        templates.push(...argument.properties
            .filter(typescript_1.isPropertyAssignment)
            .filter((prop) => (0, typescript_1.isIdentifier)(prop.name) && prop.name.text === 'template')
            .map((prop) => prop.initializer)
            .filter(orGuard(typescript_1.isStringLiteral, typescript_1.isNoSubstitutionTemplateLiteral))
            .map((initializer) => ({
            offsetStart: initializer.getStart(sourcefile) + initializer.getLeadingTriviaWidth(sourcefile),
            offsetEnd: initializer.getEnd(),
            content: 'rawText' in initializer && initializer.rawText ? initializer.rawText : initializer.text,
        })));
    }));
    return templates;
}
exports.extractNgTemplates = extractNgTemplates;
function createVisitor(predicate, callback) {
    return function visit(node) {
        if (predicate(node)) {
            callback(node);
        }
        (0, typescript_1.forEachChild)(node, visit);
    };
}
exports.createVisitor = createVisitor;
function orGuard(guard1, guard2) {
    return (item) => guard1(item) || guard2(item);
}
