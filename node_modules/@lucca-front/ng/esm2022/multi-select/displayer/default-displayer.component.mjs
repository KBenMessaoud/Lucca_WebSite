import { AsyncPipe, NgFor, NgIf, NgPlural, NgPluralCase } from '@angular/common';
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, DestroyRef, ElementRef, HostBinding, NgZone, ViewChild, ViewChildren, inject, } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { getIntl } from '@lucca-front/ng/core';
import { LU_OPTION_CONTEXT, ɵLuOptionOutletDirective } from '@lucca-front/ng/core-select';
import { LuTooltipModule } from '@lucca-front/ng/tooltip';
import { Observable, ReplaySubject, combineLatest, concatMap, debounceTime, distinctUntilChanged, map, startWith } from 'rxjs';
import { LuMultiSelectInputComponent } from '../input';
import { LU_MULTI_SELECT_DISPLAYER_TRANSLATIONS } from './default-displayer.translate';
import * as i0 from "@angular/core";
function fromElementWidth(el) {
    return new Observable((observer) => {
        // Emit the initial width
        observer.next(el.getBoundingClientRect().width);
        // Emit the new width whenever the element is resized
        const resizeObserver = new ResizeObserver((entries) => observer.next(entries[0].contentRect.width));
        resizeObserver.observe(el);
        // Cleanup observer on cancellation
        return () => resizeObserver.disconnect();
    }).pipe(distinctUntilChanged());
}
class LuMultiSelectDefaultDisplayerComponent {
    constructor() {
        this.select = inject(LuMultiSelectInputComponent);
        this.elementRef = inject(ElementRef);
        this.cdr = inject(ChangeDetectorRef);
        this.intl = getIntl(LU_MULTI_SELECT_DISPLAYER_TRANSLATIONS);
        this.destroyRef = inject(DestroyRef);
        this.zone = inject(NgZone);
        this.ngAfterViewInit$ = new ReplaySubject(1);
        this.chips$ = this.ngAfterViewInit$.pipe(concatMap(() => this.chipsQL.changes.pipe(startWith(undefined))), map(() => this.chipsQL.toArray().map((chip) => chip.nativeElement)));
        this.context = inject(LU_OPTION_CONTEXT);
        this.visibleChips$ = new ReplaySubject(1);
        this.hiddenChips$ = new ReplaySubject(1);
        this.visibleChipsCount$ = this.visibleChips$.pipe(map((chips) => chips.length), distinctUntilChanged());
        this.hiddenChipsCount$ = this.hiddenChips$.pipe(map((chips) => chips.length), distinctUntilChanged());
        this.hiddenOptionCountWidthCssVar = 0;
        this.hiddenOptionCountOffsetLeftCssVar = 0;
    }
    get disabled() {
        return this.select.disabled;
    }
    ngOnInit() {
        this.visibleChips$.pipe(takeUntilDestroyed(this.destroyRef)).subscribe((visible) => {
            this.hiddenOptionCountOffsetLeftCssVar = visible.length ? visible[visible.length - 1].offsetLeft + visible[visible.length - 1].offsetWidth : 0;
            this.cdr.markForCheck();
        });
        this.hiddenChipsCount$.pipe(takeUntilDestroyed(this.destroyRef)).subscribe((hidden) => {
            this.hiddenOptionCountWidthCssVar = hidden;
            this.cdr.markForCheck();
        });
        combineLatest([fromElementWidth(this.chipsContainer.nativeElement), fromElementWidth(this.overflowCountContainer.nativeElement), this.chips$])
            .pipe(debounceTime(0), map(([containerWidth, counterWidth, chips]) => {
            const baseOffsetTop = this.elementRef.nativeElement.offsetTop;
            const isOutOfContainer = (chip, allowedWidth) => chip.offsetTop > baseOffsetTop || chip.offsetLeft + chip.offsetWidth > allowedWidth;
            const needsCounterSpace = !!chips.length && isOutOfContainer(chips[chips.length - 1], containerWidth);
            const availableWidth = needsCounterSpace ? containerWidth - counterWidth : containerWidth;
            // First on next line or first out of container
            const firstHiddenIndex = chips.findIndex((chip) => isOutOfContainer(chip, availableWidth));
            return firstHiddenIndex !== -1
                ? {
                    visible: chips.slice(0, firstHiddenIndex),
                    hidden: chips.slice(firstHiddenIndex),
                }
                : {
                    visible: chips,
                    hidden: [],
                };
        }), takeUntilDestroyed(this.destroyRef))
            .subscribe(({ visible, hidden }) => {
            this.zone.run(() => {
                this.visibleChips$.next(visible);
                this.hiddenChips$.next(hidden);
            });
        });
    }
    unselectOption(option, $event) {
        $event.stopPropagation();
        $event.preventDefault();
        this.select.updateValue(this.select.value.filter((o) => o !== option));
    }
    ngOnDestroy() {
        this.ngAfterViewInit$.complete();
    }
    ngAfterViewInit() {
        this.ngAfterViewInit$.next();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.3", ngImport: i0, type: LuMultiSelectDefaultDisplayerComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.1.3", type: LuMultiSelectDefaultDisplayerComponent, isStandalone: true, selector: "lu-multi-select-default-displayer", host: { properties: { "style.--hidden-option-count-width.px": "this.hiddenOptionCountWidthCssVar", "style.--hidden-option-count-offset-left.px": "this.hiddenOptionCountOffsetLeftCssVar" } }, viewQueries: [{ propertyName: "overflowCountContainer", first: true, predicate: ["overflow"], descendants: true, static: true }, { propertyName: "chipsContainer", first: true, predicate: ["chipsContainer"], descendants: true, static: true }, { propertyName: "chipsQL", predicate: ["chip"], descendants: true }], ngImport: i0, template: `
		<div class="chips-container" #chipsContainer>
			<div
				#chip
				*ngFor="let option of context.option$ | async; let index = index"
				class="chip lu-multiselect-chip"
				[class.mod-unkillable]="disabled"
				[attr.aria-hidden]="index >= ((visibleChipsCount$ | async) || 0) ? 'true' : undefined"
			>
				<span class="lu-multiselect-chip-value"><ng-container *luOptionOutlet="select.valueTpl || select.optionTpl; value: option"></ng-container></span>
				<a href *ngIf="!disabled" type="button" class="chip-kill" (click)="unselectOption(option, $event)" [attr.tabindex]="index >= ((visibleChipsCount$ | async) || 0) ? -1 : undefined"></a>
			</div>
		</div>
		<div class="lu-multiselect-counter" #overflow>
			<ng-container *ngIf="hiddenChipsCount$ | async as count">
				<div class="chip mod-unkillable lu-multiselect-counter-chip" aria-hidden="true">+ {{ count }}</div>
				<span class="u-mask" [ngPlural]="count">
					<ng-template ngPluralCase="=1">{{ intl.otherResult }}</ng-template>
					<ng-template ngPluralCase="other">{{ intl.otherResults }}</ng-template>
				</span>
			</ng-container>
		</div>
	`, isInline: true, styles: [":host{display:flex;height:var(--sizes-M-lineHeight);position:relative;padding-right:var(--hidden-option-count-width);overflow:hidden}:host-context(.textfield.mod-S){height:var(--sizes-S-lineHeight)}:host-context(lu-multi-select.is-disabled) .chip{background:var(--palettes-grey-100);color:var(--palettes-grey-500)}:host-context(lu-multi-select.is-disabled) .chip .chip-kill{display:none}.lu-multiselect-counter{position:absolute;top:0;left:calc(var(--hidden-option-count-offset-left) + var(--spacings-XXS))}.lu-multiselect-counter-chip:focus-visible{outline:2px solid var(--palettes-primary-700);outline-offset:2px}.lu-multiselect-chip[aria-hidden]{visibility:hidden}.lu-multiselect-chip-value{max-width:4rem;text-overflow:ellipsis;overflow:hidden}\n"], dependencies: [{ kind: "pipe", type: AsyncPipe, name: "async" }, { kind: "ngmodule", type: LuTooltipModule }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: NgPlural, selector: "[ngPlural]", inputs: ["ngPlural"] }, { kind: "directive", type: NgPluralCase, selector: "[ngPluralCase]" }, { kind: "directive", type: ɵLuOptionOutletDirective, selector: "[luOptionOutlet]", inputs: ["luOptionOutlet", "luOptionOutletValue"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
export { LuMultiSelectDefaultDisplayerComponent };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.3", ngImport: i0, type: LuMultiSelectDefaultDisplayerComponent, decorators: [{
            type: Component,
            args: [{ selector: 'lu-multi-select-default-displayer', standalone: true, imports: [AsyncPipe, LuTooltipModule, NgIf, NgFor, NgPlural, NgPluralCase, ɵLuOptionOutletDirective], template: `
		<div class="chips-container" #chipsContainer>
			<div
				#chip
				*ngFor="let option of context.option$ | async; let index = index"
				class="chip lu-multiselect-chip"
				[class.mod-unkillable]="disabled"
				[attr.aria-hidden]="index >= ((visibleChipsCount$ | async) || 0) ? 'true' : undefined"
			>
				<span class="lu-multiselect-chip-value"><ng-container *luOptionOutlet="select.valueTpl || select.optionTpl; value: option"></ng-container></span>
				<a href *ngIf="!disabled" type="button" class="chip-kill" (click)="unselectOption(option, $event)" [attr.tabindex]="index >= ((visibleChipsCount$ | async) || 0) ? -1 : undefined"></a>
			</div>
		</div>
		<div class="lu-multiselect-counter" #overflow>
			<ng-container *ngIf="hiddenChipsCount$ | async as count">
				<div class="chip mod-unkillable lu-multiselect-counter-chip" aria-hidden="true">+ {{ count }}</div>
				<span class="u-mask" [ngPlural]="count">
					<ng-template ngPluralCase="=1">{{ intl.otherResult }}</ng-template>
					<ng-template ngPluralCase="other">{{ intl.otherResults }}</ng-template>
				</span>
			</ng-container>
		</div>
	`, changeDetection: ChangeDetectionStrategy.OnPush, styles: [":host{display:flex;height:var(--sizes-M-lineHeight);position:relative;padding-right:var(--hidden-option-count-width);overflow:hidden}:host-context(.textfield.mod-S){height:var(--sizes-S-lineHeight)}:host-context(lu-multi-select.is-disabled) .chip{background:var(--palettes-grey-100);color:var(--palettes-grey-500)}:host-context(lu-multi-select.is-disabled) .chip .chip-kill{display:none}.lu-multiselect-counter{position:absolute;top:0;left:calc(var(--hidden-option-count-offset-left) + var(--spacings-XXS))}.lu-multiselect-counter-chip:focus-visible{outline:2px solid var(--palettes-primary-700);outline-offset:2px}.lu-multiselect-chip[aria-hidden]{visibility:hidden}.lu-multiselect-chip-value{max-width:4rem;text-overflow:ellipsis;overflow:hidden}\n"] }]
        }], propDecorators: { overflowCountContainer: [{
                type: ViewChild,
                args: ['overflow', { static: true }]
            }], chipsContainer: [{
                type: ViewChild,
                args: ['chipsContainer', { static: true }]
            }], chipsQL: [{
                type: ViewChildren,
                args: ['chip']
            }], hiddenOptionCountWidthCssVar: [{
                type: HostBinding,
                args: ['style.--hidden-option-count-width.px']
            }], hiddenOptionCountOffsetLeftCssVar: [{
                type: HostBinding,
                args: ['style.--hidden-option-count-offset-left.px']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVmYXVsdC1kaXNwbGF5ZXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvbmcvbXVsdGktc2VsZWN0L2Rpc3BsYXllci9kZWZhdWx0LWRpc3BsYXllci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxZQUFZLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUNqRixPQUFPLEVBRU4sdUJBQXVCLEVBQ3ZCLGlCQUFpQixFQUNqQixTQUFTLEVBQ1QsVUFBVSxFQUNWLFVBQVUsRUFDVixXQUFXLEVBQ1gsTUFBTSxFQUlOLFNBQVMsRUFDVCxZQUFZLEVBQ1osTUFBTSxHQUNOLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQ2hFLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUMvQyxPQUFPLEVBQW9CLGlCQUFpQixFQUFFLHdCQUF3QixFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFDNUcsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQzFELE9BQU8sRUFBRSxVQUFVLEVBQUUsYUFBYSxFQUFFLGFBQWEsRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUFFLG9CQUFvQixFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDL0gsT0FBTyxFQUFFLDJCQUEyQixFQUFFLE1BQU0sVUFBVSxDQUFDO0FBQ3ZELE9BQU8sRUFBRSxzQ0FBc0MsRUFBRSxNQUFNLCtCQUErQixDQUFDOztBQUV2RixTQUFTLGdCQUFnQixDQUFDLEVBQWU7SUFDeEMsT0FBTyxJQUFJLFVBQVUsQ0FBUyxDQUFDLFFBQVEsRUFBRSxFQUFFO1FBQzFDLHlCQUF5QjtRQUN6QixRQUFRLENBQUMs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QUMsQ0FBQyxLQUFLLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDeEUsQ0FBQztJQUVELFdBQVc7UUFDVixJQUFJLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDbEMsQ0FBQztJQUVELGVBQWU7UUFDZCxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDOUIsQ0FBQzs4R0ExR1csc0NBQXNDO2tHQUF0QyxzQ0FBc0Msb2xCQTFCeEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFzQlQsbXpCQXZCUyxTQUFTLDZDQUFFLGVBQWUsK0JBQUUsSUFBSSw2RkFBRSxLQUFLLG1IQUFFLFFBQVEsNkVBQUUsWUFBWSwyREFBRSx3QkFBd0I7O1NBMkJ2RixzQ0FBc0M7MkZBQXRDLHNDQUFzQztrQkE5QmxELFNBQVM7K0JBQ0MsbUNBQW1DLGNBQ2pDLElBQUksV0FDUCxDQUFDLFNBQVMsRUFBRSxlQUFlLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsWUFBWSxFQUFFLHdCQUF3QixDQUFDLFlBQzFGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBc0JULG1CQUVnQix1QkFBdUIsQ0FBQyxNQUFNOzhCQWdCL0Msc0JBQXNCO3NCQURyQixTQUFTO3VCQUFDLFVBQVUsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7Z0JBSXZDLGNBQWM7c0JBRGIsU0FBUzt1QkFBQyxnQkFBZ0IsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7Z0JBSTdDLE9BQU87c0JBRE4sWUFBWTt1QkFBQyxNQUFNO2dCQXlCcEIsNEJBQTRCO3NCQUQzQixXQUFXO3VCQUFDLHNDQUFzQztnQkFJbkQsaUNBQWlDO3NCQURoQyxXQUFXO3VCQUFDLDRDQUE0QyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFzeW5jUGlwZSwgTmdGb3IsIE5nSWYsIE5nUGx1cmFsLCBOZ1BsdXJhbENhc2UgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtcblx0QWZ0ZXJWaWV3SW5pdCxcblx0Q2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG5cdENoYW5nZURldGVjdG9yUmVmLFxuXHRDb21wb25lbnQsXG5cdERlc3Ryb3lSZWYsXG5cdEVsZW1lbnRSZWYsXG5cdEhvc3RCaW5kaW5nLFxuXHROZ1pvbmUsXG5cdE9uRGVzdHJveSxcblx0T25Jbml0LFxuXHRRdWVyeUxpc3QsXG5cdFZpZXdDaGlsZCxcblx0Vmlld0NoaWxkcmVuLFxuXHRpbmplY3QsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgdGFrZVVudGlsRGVzdHJveWVkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZS9yeGpzLWludGVyb3AnO1xuaW1wb3J0IHsgZ2V0SW50bCB9IGZyb20gJ0BsdWNjYS1mcm9udC9uZy9jb3JlJztcbmltcG9ydCB7IElMdU9wdGlvbkNvbnRleHQsIExVX09QVElPTl9DT05URVhULCDJtUx1T3B0aW9uT3V0bGV0RGlyZWN0aXZlIH0gZnJvbSAnQGx1Y2NhLWZyb250L25nL2NvcmUtc2VsZWN0JztcbmltcG9ydCB7IEx1VG9vbHRpcE1vZHVsZSB9IGZyb20gJ0BsdWNjYS1mcm9udC9uZy90b29sdGlwJztcbmltcG9ydCB7IE9ic2VydmFibGUsIFJlcGxheVN1YmplY3QsIGNvbWJpbmVMYXRlc3QsIGNvbmNhdE1hcCwgZGVib3VuY2VUaW1lLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgbWFwLCBzdGFydFdpdGggfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IEx1TXVsdGlTZWxlY3RJbnB1dENvbXBvbmVudCB9IGZyb20gJy4uL2lucHV0JztcbmltcG9ydCB7IExVX01VTFRJX1NFTEVDVF9ESVNQTEFZRVJfVFJBTlNMQVRJT05TIH0gZnJvbSAnLi9kZWZhdWx0LWRpc3BsYXllci50cmFuc2xhdGUnO1xuXG5mdW5jdGlvbiBmcm9tRWxlbWVudFdpZHRoKGVsOiBIVE1MRWxlbWVudCk6IE9ic2VydmFibGU8bnVtYmVyPiB7XG5cdHJldHVybiBuZXcgT2JzZXJ2YWJsZTxudW1iZXI+KChvYnNlcnZlcikgPT4ge1xuXHRcdC8vIEVtaXQgdGhlIGluaXRpYWwgd2lkdGhcblx0XHRvYnNlcnZlci5uZXh0KGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoKTtcblxuXHRcdC8vIEVtaXQgdGhlIG5ldyB3aWR0aCB3aGVuZXZlciB0aGUgZWxlbWVudCBpcyByZXNpemVkXG5cdFx0Y29uc3QgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKGVudHJpZXMpID0+IG9ic2VydmVyLm5leHQoZW50cmllc1swXS5jb250ZW50UmVjdC53aWR0aCkpO1xuXHRcdHJlc2l6ZU9ic2VydmVyLm9ic2VydmUoZWwpO1xuXG5cdFx0Ly8gQ2xlYW51cCBvYnNlcnZlciBvbiBjYW5jZWxsYXRpb25cblx0XHRyZXR1cm4gKCkgPT4gcmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuXHR9KS5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKCkpO1xufVxuXG5AQ29tcG9uZW50KHtcblx0c2VsZWN0b3I6ICdsdS1tdWx0aS1zZWxlY3QtZGVmYXVsdC1kaXNwbGF5ZXInLFxuXHRzdGFuZGFsb25lOiB0cnVlLFxuXHRpbXBvcnRzOiBbQXN5bmNQaXBlLCBMdVRvb2x0aXBNb2R1bGUsIE5nSWYsIE5nRm9yLCBOZ1BsdXJhbCwgTmdQbHVyYWxDYXNlLCDJtUx1T3B0aW9uT3V0bGV0RGlyZWN0aXZlXSxcblx0dGVtcGxhdGU6IGBcblx0XHQ8ZGl2IGNsYXNzPVwiY2hpcHMtY29udGFpbmVyXCIgI2NoaXBzQ29udGFpbmVyPlxuXHRcdFx0PGRpdlxuXHRcdFx0XHQjY2hpcFxuXHRcdFx0XHQqbmdGb3I9XCJsZXQgb3B0aW9uIG9mIGNvbnRleHQub3B0aW9uJCB8IGFzeW5jOyBsZXQgaW5kZXggPSBpbmRleFwiXG5cdFx0XHRcdGNsYXNzPVwiY2hpcCBsdS1tdWx0aXNlbGVjdC1jaGlwXCJcblx0XHRcdFx0W2NsYXNzLm1vZC11bmtpbGxhYmxlXT1cImRpc2FibGVkXCJcblx0XHRcdFx0W2F0dHIuYXJpYS1oaWRkZW5dPVwiaW5kZXggPj0gKCh2aXNpYmxlQ2hpcHNDb3VudCQgfCBhc3luYykgfHwgMCkgPyAndHJ1ZScgOiB1bmRlZmluZWRcIlxuXHRcdFx0PlxuXHRcdFx0XHQ8c3BhbiBjbGFzcz1cImx1LW11bHRpc2VsZWN0LWNoaXAtdmFsdWVcIj48bmctY29udGFpbmVyICpsdU9wdGlvbk91dGxldD1cInNlbGVjdC52YWx1ZVRwbCB8fCBzZWxlY3Qub3B0aW9uVHBsOyB2YWx1ZTogb3B0aW9uXCI+PC9uZy1jb250YWluZXI+PC9zcGFuPlxuXHRcdFx0XHQ8YSBocmVmICpuZ0lmPVwiIWRpc2FibGVkXCIgdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiY2hpcC1raWxsXCIgKGNsaWNrKT1cInVuc2VsZWN0T3B0aW9uKG9wdGlvbiwgJGV2ZW50KVwiIFthdHRyLnRhYmluZGV4XT1cImluZGV4ID49ICgodmlzaWJsZUNoaXBzQ291bnQkIHwgYXN5bmMpIHx8IDApID8gLTEgOiB1bmRlZmluZWRcIj48L2E+XG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L2Rpdj5cblx0XHQ8ZGl2IGNsYXNzPVwibHUtbXVsdGlzZWxlY3QtY291bnRlclwiICNvdmVyZmxvdz5cblx0XHRcdDxuZy1jb250YWluZXIgKm5nSWY9XCJoaWRkZW5DaGlwc0NvdW50JCB8IGFzeW5jIGFzIGNvdW50XCI+XG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJjaGlwIG1vZC11bmtpbGxhYmxlIGx1LW11bHRpc2VsZWN0LWNvdW50ZXItY2hpcFwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPisge3sgY291bnQgfX08L2Rpdj5cblx0XHRcdFx0PHNwYW4gY2xhc3M9XCJ1LW1hc2tcIiBbbmdQbHVyYWxdPVwiY291bnRcIj5cblx0XHRcdFx0XHQ8bmctdGVtcGxhdGUgbmdQbHVyYWxDYXNlPVwiPTFcIj57eyBpbnRsLm90aGVyUmVzdWx0IH19PC9uZy10ZW1wbGF0ZT5cblx0XHRcdFx0XHQ8bmctdGVtcGxhdGUgbmdQbHVyYWxDYXNlPVwib3RoZXJcIj57eyBpbnRsLm90aGVyUmVzdWx0cyB9fTwvbmctdGVtcGxhdGU+XG5cdFx0XHRcdDwvc3Bhbj5cblx0XHRcdDwvbmctY29udGFpbmVyPlxuXHRcdDwvZGl2PlxuXHRgLFxuXHRzdHlsZVVybHM6IFsnLi9kZWZhdWx0LWRpc3BsYXllci5jb21wb25lbnQuc2NzcyddLFxuXHRjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbn0pXG5leHBvcnQgY2xhc3MgTHVNdWx0aVNlbGVjdERlZmF1bHREaXNwbGF5ZXJDb21wb25lbnQ8VD4gaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBPbkluaXQsIE9uRGVzdHJveSB7XG5cdHNlbGVjdCA9IGluamVjdDxMdU11bHRpU2VsZWN0SW5wdXRDb21wb25lbnQ8VD4+KEx1TXVsdGlTZWxlY3RJbnB1dENvbXBvbmVudCk7XG5cdGVsZW1lbnRSZWYgPSBpbmplY3Q8RWxlbWVudFJlZjxIVE1MRWxlbWVudD4+KEVsZW1lbnRSZWYpO1xuXHRjZHIgPSBpbmplY3QoQ2hhbmdlRGV0ZWN0b3JSZWYpO1xuXHRpbnRsID0gZ2V0SW50bChMVV9NVUxUSV9TRUxFQ1RfRElTUExBWUVSX1RSQU5TTEFUSU9OUyk7XG5cblx0cHJvdGVjdGVkIGRlc3Ryb3lSZWYgPSBpbmplY3QoRGVzdHJveVJlZik7XG5cdHByb3RlY3RlZCB6b25lID0gaW5qZWN0KE5nWm9uZSk7XG5cblx0Z2V0IGRpc2FibGVkKCkge1xuXHRcdHJldHVybiB0aGlzLnNlbGVjdC5kaXNhYmxlZDtcblx0fVxuXG5cdEBWaWV3Q2hpbGQoJ292ZXJmbG93JywgeyBzdGF0aWM6IHRydWUgfSlcblx0b3ZlcmZsb3dDb3VudENvbnRhaW5lcjogRWxlbWVudFJlZjxIVE1MRWxlbWVudD47XG5cblx0QFZpZXdDaGlsZCgnY2hpcHNDb250YWluZXInLCB7IHN0YXRpYzogdHJ1ZSB9KVxuXHRjaGlwc0NvbnRhaW5lcjogRWxlbWVudFJlZjxIVE1MRWxlbWVudD47XG5cblx0QFZpZXdDaGlsZHJlbignY2hpcCcpXG5cdGNoaXBzUUw6IFF1ZXJ5TGlzdDxFbGVtZW50UmVmPEhUTUxFbGVtZW50Pj47XG5cblx0cHJvdGVjdGVkIG5nQWZ0ZXJWaWV3SW5pdCQgPSBuZXcgUmVwbGF5U3ViamVjdDx2b2lkPigxKTtcblxuXHRjaGlwcyQ6IE9ic2VydmFibGU8SFRNTEVsZW1lbnRbXT4gPSB0aGlzLm5nQWZ0ZXJWaWV3SW5pdCQucGlwZShcblx0XHRjb25jYXRNYXAoKCkgPT4gdGhpcy5jaGlwc1FMLmNoYW5nZXMucGlwZShzdGFydFdpdGgodW5kZWZpbmVkKSkpLFxuXHRcdG1hcCgoKSA9PiB0aGlzLmNoaXBzUUwudG9BcnJheSgpLm1hcCgoY2hpcCkgPT4gY2hpcC5uYXRpdmVFbGVtZW50KSksXG5cdCk7XG5cblx0Y29udGV4dCA9IGluamVjdDxJTHVPcHRpb25Db250ZXh0PFRbXT4+KExVX09QVElPTl9DT05URVhUKTtcblxuXHRwcm90ZWN0ZWQgdmlzaWJsZUNoaXBzJCA9IG5ldyBSZXBsYXlTdWJqZWN0PEhUTUxFbGVtZW50W10+KDEpO1xuXHRwcm90ZWN0ZWQgaGlkZGVuQ2hpcHMkID0gbmV3IFJlcGxheVN1YmplY3Q8SFRNTEVsZW1lbnRbXT4oMSk7XG5cblx0dmlzaWJsZUNoaXBzQ291bnQkID0gdGhpcy52aXNpYmxlQ2hpcHMkLnBpcGUoXG5cdFx0bWFwKChjaGlwcykgPT4gY2hpcHMubGVuZ3RoKSxcblx0XHRkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLFxuXHQpO1xuXHRoaWRkZW5DaGlwc0NvdW50JCA9IHRoaXMuaGlkZGVuQ2hpcHMkLnBpcGUoXG5cdFx0bWFwKChjaGlwcykgPT4gY2hpcHMubGVuZ3RoKSxcblx0XHRkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLFxuXHQpO1xuXG5cdEBIb3N0QmluZGluZygnc3R5bGUuLS1oaWRkZW4tb3B0aW9uLWNvdW50LXdpZHRoLnB4Jylcblx0aGlkZGVuT3B0aW9uQ291bnRXaWR0aENzc1ZhciA9IDA7XG5cblx0QEhvc3RCaW5kaW5nKCdzdHlsZS4tLWhpZGRlbi1vcHRpb24tY291bnQtb2Zmc2V0LWxlZnQucHgnKVxuXHRoaWRkZW5PcHRpb25Db3VudE9mZnNldExlZnRDc3NWYXIgPSAwO1xuXG5cdG5nT25Jbml0KCk6IHZvaWQge1xuXHRcdHRoaXMudmlzaWJsZUNoaXBzJC5waXBlKHRha2VVbnRpbERlc3Ryb3llZCh0aGlzLmRlc3Ryb3lSZWYpKS5zdWJzY3JpYmUoKHZpc2libGUpID0+IHtcblx0XHRcdHRoaXMuaGlkZGVuT3B0aW9uQ291bnRPZmZzZXRMZWZ0Q3NzVmFyID0gdmlzaWJsZS5sZW5ndGggPyB2aXNpYmxlW3Zpc2libGUubGVuZ3RoIC0gMV0ub2Zmc2V0TGVmdCArIHZpc2libGVbdmlzaWJsZS5sZW5ndGggLSAxXS5vZmZzZXRXaWR0aCA6IDA7XG5cdFx0XHR0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcblx0XHR9KTtcblxuXHRcdHRoaXMuaGlkZGVuQ2hpcHNDb3VudCQucGlwZSh0YWtlVW50aWxEZXN0cm95ZWQodGhpcy5kZXN0cm95UmVmKSkuc3Vic2NyaWJlKChoaWRkZW4pID0+IHtcblx0XHRcdHRoaXMuaGlkZGVuT3B0aW9uQ291bnRXaWR0aENzc1ZhciA9IGhpZGRlbjtcblx0XHRcdHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuXHRcdH0pO1xuXG5cdFx0Y29tYmluZUxhdGVzdChbZnJvbUVsZW1lbnRXaWR0aCh0aGlzLmNoaXBzQ29udGFpbmVyLm5hdGl2ZUVsZW1lbnQpLCBmcm9tRWxlbWVudFdpZHRoKHRoaXMub3ZlcmZsb3dDb3VudENvbnRhaW5lci5uYXRpdmVFbGVtZW50KSwgdGhpcy5jaGlwcyRdKVxuXHRcdFx0LnBpcGUoXG5cdFx0XHRcdGRlYm91bmNlVGltZSgwKSxcblx0XHRcdFx0bWFwKChbY29udGFpbmVyV2lkdGgsIGNvdW50ZXJXaWR0aCwgY2hpcHNdKSA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgYmFzZU9mZnNldFRvcCA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50Lm9mZnNldFRvcDtcblxuXHRcdFx0XHRcdGNvbnN0IGlzT3V0T2ZDb250YWluZXIgPSAoY2hpcDogSFRNTEVsZW1lbnQsIGFsbG93ZWRXaWR0aDogbnVtYmVyKSA9PiBjaGlwLm9mZnNldFRvcCA+IGJhc2VPZmZzZXRUb3AgfHwgY2hpcC5vZmZzZXRMZWZ0ICsgY2hpcC5vZmZzZXRXaWR0aCA+IGFsbG93ZWRXaWR0aDtcblxuXHRcdFx0XHRcdGNvbnN0IG5lZWRzQ291bnRlclNwYWNlID0gISFjaGlwcy5sZW5ndGggJiYgaXNPdXRPZkNvbnRhaW5lcihjaGlwc1tjaGlwcy5sZW5ndGggLSAxXSwgY29udGFpbmVyV2lkdGgpO1xuXHRcdFx0XHRcdGNvbnN0IGF2YWlsYWJsZVdpZHRoID0gbmVlZHNDb3VudGVyU3BhY2UgPyBjb250YWluZXJXaWR0aCAtIGNvdW50ZXJXaWR0aCA6IGNvbnRhaW5lcldpZHRoO1xuXG5cdFx0XHRcdFx0Ly8gRmlyc3Qgb24gbmV4dCBsaW5lIG9yIGZpcnN0IG91dCBvZiBjb250YWluZXJcblx0XHRcdFx0XHRjb25zdCBmaXJzdEhpZGRlbkluZGV4ID0gY2hpcHMuZmluZEluZGV4KChjaGlwKSA9PiBpc091dE9mQ29udGFpbmVyKGNoaXAsIGF2YWlsYWJsZVdpZHRoKSk7XG5cblx0XHRcdFx0XHRyZXR1cm4gZmlyc3RIaWRkZW5JbmRleCAhPT0gLTFcblx0XHRcdFx0XHRcdD8ge1xuXHRcdFx0XHRcdFx0XHRcdHZpc2libGU6IGNoaXBzLnNsaWNlKDAsIGZpcnN0SGlkZGVuSW5kZXgpLFxuXHRcdFx0XHRcdFx0XHRcdGhpZGRlbjogY2hpcHMuc2xpY2UoZmlyc3RIaWRkZW5JbmRleCksXG5cdFx0XHRcdFx0XHQgIH1cblx0XHRcdFx0XHRcdDoge1xuXHRcdFx0XHRcdFx0XHRcdHZpc2libGU6IGNoaXBzLFxuXHRcdFx0XHRcdFx0XHRcdGhpZGRlbjogW10sXG5cdFx0XHRcdFx0XHQgIH07XG5cdFx0XHRcdH0pLFxuXHRcdFx0XHR0YWtlVW50aWxEZXN0cm95ZWQodGhpcy5kZXN0cm95UmVmKSxcblx0XHRcdClcblx0XHRcdC5zdWJzY3JpYmUoKHsgdmlzaWJsZSwgaGlkZGVuIH0pID0+IHtcblx0XHRcdFx0dGhpcy56b25lLnJ1bigoKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy52aXNpYmxlQ2hpcHMkLm5leHQodmlzaWJsZSk7XG5cdFx0XHRcdFx0dGhpcy5oaWRkZW5DaGlwcyQubmV4dChoaWRkZW4pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHR9XG5cblx0dW5zZWxlY3RPcHRpb24ob3B0aW9uOiBULCAkZXZlbnQ6IEV2ZW50KTogdm9pZCB7XG5cdFx0JGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdCRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdHRoaXMuc2VsZWN0LnVwZGF0ZVZhbHVlKHRoaXMuc2VsZWN0LnZhbHVlLmZpbHRlcigobykgPT4gbyAhPT0gb3B0aW9uKSk7XG5cdH1cblxuXHRuZ09uRGVzdHJveSgpOiB2b2lkIHtcblx0XHR0aGlzLm5nQWZ0ZXJWaWV3SW5pdCQuY29tcGxldGUoKTtcblx0fVxuXG5cdG5nQWZ0ZXJWaWV3SW5pdCgpIHtcblx0XHR0aGlzLm5nQWZ0ZXJWaWV3SW5pdCQubmV4dCgpO1xuXHR9XG59XG4iXX0=