import { Directive, inject, Input, Renderer2, TemplateRef, ViewContainerRef } from '@angular/core';
import * as i0 from "@angular/core";
class PortalDirective {
    constructor() {
        this.viewContainerRef = inject(ViewContainerRef);
        this.renderer = inject(Renderer2);
        this.templateRef = inject(TemplateRef);
        this.luPortal = null;
    }
    render() {
        this.viewContainerRef.clear();
        if (this.luPortal instanceof TemplateRef) {
            this.viewContainerRef.createEmbeddedView(this.luPortal);
        }
        else {
            const ref = this.viewContainerRef.createEmbeddedView(this.templateRef);
            const container = ref.rootNodes[0];
            const parent = container.parentElement;
            this.renderer.insertBefore(parent, document.createTextNode(this.luPortal), container);
        }
    }
    ngOnChanges(changes) {
        if (changes['luPortal']) {
            // If we're here, it means that either the template ref changed or the string changed,
            // meaning that we need to render again
            this.render();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.3", ngImport: i0, type: PortalDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.1.3", type: PortalDirective, isStandalone: true, selector: "[luPortal]", inputs: { luPortal: "luPortal" }, usesOnChanges: true, ngImport: i0 }); }
}
export { PortalDirective };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.3", ngImport: i0, type: PortalDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[luPortal]',
                    standalone: true,
                }]
        }], propDecorators: { luPortal: [{
                type: Input,
                args: [{ required: true }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9ydGFsLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL25nL2NvcmUvcG9ydGFsL3BvcnRhbC5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFhLFNBQVMsRUFBaUIsV0FBVyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sZUFBZSxDQUFDOztBQUc3SCxNQUlhLGVBQWU7SUFKNUI7UUFLUyxxQkFBZ0IsR0FBRyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztRQUM1QyxhQUFRLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQzdCLGdCQUFXLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBR25DLGFBQVEsR0FBcUIsSUFBSSxDQUFDO0tBc0J6QztJQXBCUSxNQUFNO1FBQ2IsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEtBQUssRUFBRSxDQUFDO1FBRTlCLElBQUksSUFBSSxDQUFDLFFBQVEsWUFBWSxXQUFXLEVBQUU7WUFDekMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUN4RDthQUFNO1lBQ04sTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUN2RSxNQUFNLFNBQVMsR0FBZ0IsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQWdCLENBQUM7WUFDL0QsTUFBTSxNQUFNLEdBQUcsU0FBUyxDQUFDLGFBQWEsQ0FBQztZQUN2QyxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxNQUFNLEVBQUUsUUFBUSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUM7U0FDdEY7SUFDRixDQUFDO0lBRUQsV0FBVyxDQUFDLE9BQXNCO1FBQ2pDLElBQUksT0FBTyxDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQ3hCLHNGQUFzRjtZQUN0Rix1Q0FBdUM7WUFDdkMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1NBQ2Q7SUFDRixDQUFDOzhHQTNCVyxlQUFlO2tHQUFmLGVBQWU7O1NBQWYsZUFBZTsyRkFBZixlQUFlO2tCQUozQixTQUFTO21CQUFDO29CQUNWLFFBQVEsRUFBRSxZQUFZO29CQUN0QixVQUFVLEVBQUUsSUFBSTtpQkFDaEI7OEJBT08sUUFBUTtzQkFEZCxLQUFLO3VCQUFDLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSwgaW5qZWN0LCBJbnB1dCwgT25DaGFuZ2VzLCBSZW5kZXJlcjIsIFNpbXBsZUNoYW5nZXMsIFRlbXBsYXRlUmVmLCBWaWV3Q29udGFpbmVyUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBQb3J0YWxDb250ZW50IH0gZnJvbSAnLi9wb3J0YWwtY29udGVudCc7XG5cbkBEaXJlY3RpdmUoe1xuXHRzZWxlY3RvcjogJ1tsdVBvcnRhbF0nLFxuXHRzdGFuZGFsb25lOiB0cnVlLFxufSlcbmV4cG9ydCBjbGFzcyBQb3J0YWxEaXJlY3RpdmU8VCA9IHVua25vd24+IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcblx0cHJpdmF0ZSB2aWV3Q29udGFpbmVyUmVmID0gaW5qZWN0KFZpZXdDb250YWluZXJSZWYpO1xuXHRwcml2YXRlIHJlbmRlcmVyID0gaW5qZWN0KFJlbmRlcmVyMik7XG5cdHByaXZhdGUgdGVtcGxhdGVSZWYgPSBpbmplY3QoVGVtcGxhdGVSZWYpO1xuXG5cdEBJbnB1dCh7IHJlcXVpcmVkOiB0cnVlIH0pXG5cdHB1YmxpYyBsdVBvcnRhbDogUG9ydGFsQ29udGVudDxUPiA9IG51bGw7XG5cblx0cHJpdmF0ZSByZW5kZXIoKTogdm9pZCB7XG5cdFx0dGhpcy52aWV3Q29udGFpbmVyUmVmLmNsZWFyKCk7XG5cblx0XHRpZiAodGhpcy5sdVBvcnRhbCBpbnN0YW5jZW9mIFRlbXBsYXRlUmVmKSB7XG5cdFx0XHR0aGlzLnZpZXdDb250YWluZXJSZWYuY3JlYXRlRW1iZWRkZWRWaWV3KHRoaXMubHVQb3J0YWwpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCByZWYgPSB0aGlzLnZpZXdDb250YWluZXJSZWYuY3JlYXRlRW1iZWRkZWRWaWV3KHRoaXMudGVtcGxhdGVSZWYpO1xuXHRcdFx0Y29uc3QgY29udGFpbmVyOiBIVE1MRWxlbWVudCA9IHJlZi5yb290Tm9kZXNbMF0gYXMgSFRNTEVsZW1lbnQ7XG5cdFx0XHRjb25zdCBwYXJlbnQgPSBjb250YWluZXIucGFyZW50RWxlbWVudDtcblx0XHRcdHRoaXMucmVuZGVyZXIuaW5zZXJ0QmVmb3JlKHBhcmVudCwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5sdVBvcnRhbCksIGNvbnRhaW5lcik7XG5cdFx0fVxuXHR9XG5cblx0bmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuXHRcdGlmIChjaGFuZ2VzWydsdVBvcnRhbCddKSB7XG5cdFx0XHQvLyBJZiB3ZSdyZSBoZXJlLCBpdCBtZWFucyB0aGF0IGVpdGhlciB0aGUgdGVtcGxhdGUgcmVmIGNoYW5nZWQgb3IgdGhlIHN0cmluZyBjaGFuZ2VkLFxuXHRcdFx0Ly8gbWVhbmluZyB0aGF0IHdlIG5lZWQgdG8gcmVuZGVyIGFnYWluXG5cdFx0XHR0aGlzLnJlbmRlcigpO1xuXHRcdH1cblx0fVxufVxuIl19