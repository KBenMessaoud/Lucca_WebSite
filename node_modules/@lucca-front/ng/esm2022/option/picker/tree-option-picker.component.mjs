import { A11yModule } from '@angular/cdk/a11y';
import { CommonModule, DOCUMENT } from '@angular/common';
import { ChangeDetectionStrategy, Component, ContentChildren, Directive, forwardRef, Inject, ViewContainerRef } from '@angular/core';
import { ALuPickerPanel } from '@lucca-front/ng/picker';
import { luTransformPopover } from '@lucca-front/ng/popover';
import { merge } from 'rxjs';
import { delay, map, startWith, switchMap } from 'rxjs/operators';
import { ALuTreeOptionItem } from '../item/index';
import { ALuOptionPickerComponent } from './option-picker.component';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "@angular/cdk/a11y";
var ToggleMode;
(function (ToggleMode) {
    ToggleMode[ToggleMode["all"] = 0] = "all";
    ToggleMode[ToggleMode["self"] = 1] = "self";
    ToggleMode[ToggleMode["children"] = 2] = "children";
})(ToggleMode || (ToggleMode = {}));
class ALuTreeOptionPickerComponent extends ALuOptionPickerComponent {
    set optionsQL(ql) {
        this._optionsQL = ql;
    }
    set _options$(optionItems$) {
        // reapply selected when the options change
        this._subs.add(optionItems$.subscribe(() => this._applySelected()));
        // subscribe to any option.onSelect
        const singleFlowSelect$ = optionItems$.pipe(switchMap((items) => merge(...items.map((i) => i.onSelect))));
        const singleFlowSelectSelf$ = optionItems$.pipe(switchMap((items) => merge(...items.map((i) => i.onSelectSelf))));
        const singleFlowSelectChildren$ = optionItems$.pipe(switchMap((items) => merge(...items.map((i) => i.onSelectChildren))));
        this._subs.add(singleFlowSelect$.subscribe((option) => this._toggle(option, ToggleMode.all)));
        this._subs.add(singleFlowSelectSelf$.subscribe((option) => this._toggle(option, ToggleMode.self)));
        this._subs.add(singleFlowSelectChildren$.subscribe((option) => this._toggle(option, ToggleMode.children)));
    }
    constructor(_changeDetectorRef, document) {
        super(_changeDetectorRef, document);
    }
    _toggle(option, mod = ToggleMode.all) {
        switch (mod) {
            case ToggleMode.self:
                return this._toggleSelf(option);
            case ToggleMode.children:
                return this._toggleChildren(option);
            default:
                return this._toggleAll(option);
        }
    }
    _toggleAll(option) {
        const value = option.value;
        if (!this.multiple) {
            this._select(value);
            return;
        }
        const allChildren = option.allChildren.map((i) => i.value);
        const values = this._value || [];
        let newValues;
        const selfSelected = values.some((v) => this.optionComparer(v, value));
        const allChildrenSelected = allChildren.every((child) => values.some((v) => this.optionComparer(v, child)));
        if (selfSelected && allChildrenSelected) {
            // remove option and its children
            newValues = this._remove(values, [value, ...allChildren]);
        }
        else {
            // add option and its children
            newValues = this._add(values, [value, ...allChildren]);
        }
        this._select(newValues);
    }
    _toggleSelf(option) {
        const value = option.value;
        if (!this.multiple) {
            this._select(value);
            return;
        }
        const allChildren = option.allChildren.map((i) => i.value);
        const values = this._value || [];
        const selfSelected = values.some((v) => this.optionComparer(v, value));
        const someChildSelected = allChildren.some((child) => values.some((v) => this.optionComparer(v, child)));
        let newValues = this._remove(values, [...allChildren]);
        if (selfSelected && !someChildSelected) {
            // remove option
            newValues = this._remove(newValues, [value]);
        }
        else {
            // add option
            newValues = this._add(newValues, [value]);
        }
        this._select(newValues);
    }
    _toggleChildren(option) {
        const value = option.value;
        if (!this.multiple) {
            this._select(value);
            return;
        }
        const allChildren = option.allChildren.map((i) => i.value);
        const values = this._value || [];
        const selfSelected = values.some((v) => this.optionComparer(v, value));
        let newValues = this._remove(values, [value]);
        const allChildrenSelected = allChildren.every((child) => values.some((v) => this.optionComparer(v, child)));
        if (allChildrenSelected && !selfSelected) {
            newValues = this._remove(newValues, allChildren);
        }
        else {
            newValues = this._add(newValues, allChildren);
        }
        this._select(newValues);
    }
    _add(values, entries) {
        const newEntries = entries.filter((entry) => !values.some((v) => this.optionComparer(v, entry)));
        return [...values, ...newEntries];
    }
    _remove(values, entries) {
        const entriesToKeep = values.filter((value) => !entries.some((e) => this.optionComparer(e, value)));
        return [...entriesToKeep];
    }
    initItems() {
        const items$ = this._optionsQL.changes.pipe(startWith(this._optionsQL), map((q) => q.toArray()), map((roots) => roots.map((r) => [r, ...r.allChildren]).reduce((agg, val) => [...agg, ...val], [])), delay(0));
        this._subs.add(items$.subscribe((o) => (this._options = o || [])));
        this._options$ = items$;
    }
    ngAfterViewInit() {
        this.initItems();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.3", ngImport: i0, type: ALuTreeOptionPickerComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.1.3", type: ALuTreeOptionPickerComponent, queries: [{ propertyName: "optionsQL", predicate: ALuTreeOptionItem, descendants: true }, { propertyName: "optionsQLVR", predicate: ALuTreeOptionItem, descendants: true, read: ViewContainerRef }], usesInheritance: true, ngImport: i0 }); }
}
export { ALuTreeOptionPickerComponent };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.3", ngImport: i0, type: ALuTreeOptionPickerComponent, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }]; }, propDecorators: { optionsQL: [{
                type: ContentChildren,
                args: [ALuTreeOptionItem, { descendants: true }]
            }], optionsQLVR: [{
                type: ContentChildren,
                args: [ALuTreeOptionItem, {
                        descendants: true,
                        read: ViewContainerRef,
                    }]
            }] } });
/**
 * basic tree option picker panel
 */
class LuTreeOptionPickerComponent extends ALuTreeOptionPickerComponent {
    constructor(_changeDetectorRef, document) {
        super(_changeDetectorRef, document);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.3", ngImport: i0, type: LuTreeOptionPickerComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.1.3", type: LuTreeOptionPickerComponent, isStandalone: true, selector: "lu-tree-option-picker", providers: [
            {
                provide: ALuPickerPanel,
                useExisting: forwardRef(() => LuTreeOptionPickerComponent),
            },
        ], exportAs: ["LuTreeOptionPicker"], usesInheritance: true, ngImport: i0, template: "<ng-template>\n\t<div\n\t\tclass=\"lu-picker-panel lu-tree-option-picker-panel\"\n\t\trole=\"dialog\"\n\t\t[ngClass]=\"panelClassesMap\"\n\t\t[class.mod-multiple]=\"multiple\"\n\t\t(click)=\"onClick()\"\n\t\t(mouseover)=\"onMouseOver()\"\n\t\t(mouseleave)=\"onMouseLeave()\"\n\t\t(mousedown)=\"onMouseDown()\"\n\t>\n\t\t<div class=\"lu-picker-content\" [ngClass]=\"contentClassesMap\" [cdkTrapFocus]=\"trapFocus\">\n\t\t\t<div class=\"lu-picker-content-option\">\n\t\t\t\t<ng-content></ng-content>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</ng-template>\n", dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "ngmodule", type: A11yModule }, { kind: "directive", type: i2.CdkTrapFocus, selector: "[cdkTrapFocus]", inputs: ["cdkTrapFocus", "cdkTrapFocusAutoCapture"], exportAs: ["cdkTrapFocus"] }], animations: [luTransformPopover], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
export { LuTreeOptionPickerComponent };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.3", ngImport: i0, type: LuTreeOptionPickerComponent, decorators: [{
            type: Component,
            args: [{ selector: 'lu-tree-option-picker', changeDetection: ChangeDetectionStrategy.OnPush, animations: [luTransformPopover], exportAs: 'LuTreeOptionPicker', standalone: true, imports: [CommonModule, A11yModule], providers: [
                        {
                            provide: ALuPickerPanel,
                            useExisting: forwardRef(() => LuTreeOptionPickerComponent),
                        },
                    ], template: "<ng-template>\n\t<div\n\t\tclass=\"lu-picker-panel lu-tree-option-picker-panel\"\n\t\trole=\"dialog\"\n\t\t[ngClass]=\"panelClassesMap\"\n\t\t[class.mod-multiple]=\"multiple\"\n\t\t(click)=\"onClick()\"\n\t\t(mouseover)=\"onMouseOver()\"\n\t\t(mouseleave)=\"onMouseLeave()\"\n\t\t(mousedown)=\"onMouseDown()\"\n\t>\n\t\t<div class=\"lu-picker-content\" [ngClass]=\"contentClassesMap\" [cdkTrapFocus]=\"trapFocus\">\n\t\t\t<div class=\"lu-picker-content-option\">\n\t\t\t\t<ng-content></ng-content>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</ng-template>\n" }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS1vcHRpb24tcGlja2VyLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL25nL29wdGlvbi9waWNrZXIvdHJlZS1vcHRpb24tcGlja2VyLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL25nL29wdGlvbi9waWNrZXIvdHJlZS1vcHRpb24tcGlja2VyLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUMvQyxPQUFPLEVBQUUsWUFBWSxFQUFFLFFBQVEsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ3pELE9BQU8sRUFBaUIsdUJBQXVCLEVBQXFCLFNBQVMsRUFBRSxlQUFlLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQXdCLGdCQUFnQixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzdMLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUN4RCxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUM3RCxPQUFPLEVBQUUsS0FBSyxFQUFjLE1BQU0sTUFBTSxDQUFDO0FBQ3pDLE9BQU8sRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNsRSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbEQsT0FBTyxFQUFFLHdCQUF3QixFQUFFLE1BQU0sMkJBQTJCLENBQUM7Ozs7QUFHckUsSUFBSyxVQUlKO0FBSkQsV0FBSyxVQUFVO0lBQ2QseUNBQUcsQ0FBQTtJQUNILDJDQUFJLENBQUE7SUFDSixtREFBUSxDQUFBO0FBQ1QsQ0FBQyxFQUpJLFVBQVUsS0FBVixVQUFVLFFBSWQ7QUFFRCxNQUNzQiw0QkFDckIsU0FBUSx3QkFBOEI7SUFH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QUFVLENBQUMsYUFDeEI7d0JBQ1Y7NEJBQ0MsT0FBTyxFQUFFLGNBQWM7NEJBQ3ZCLFdBQVcsRUFBRSxVQUFVLENBQUMsR0FBRyxFQUFFLDRCQUE0QixDQUFDO3lCQUMxRDtxQkFDRDs7MEJBTW1ELE1BQU07MkJBQUMsUUFBUSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEExMXlNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jZGsvYTExeSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUsIERPQ1VNRU5UIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IEFmdGVyVmlld0luaXQsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDaGFuZ2VEZXRlY3RvclJlZiwgQ29tcG9uZW50LCBDb250ZW50Q2hpbGRyZW4sIERpcmVjdGl2ZSwgZm9yd2FyZFJlZiwgSW5qZWN0LCBPbkRlc3Ryb3ksIFF1ZXJ5TGlzdCwgVmlld0NvbnRhaW5lclJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQUx1UGlja2VyUGFuZWwgfSBmcm9tICdAbHVjY2EtZnJvbnQvbmcvcGlja2VyJztcbmltcG9ydCB7IGx1VHJhbnNmb3JtUG9wb3ZlciB9IGZyb20gJ0BsdWNjYS1mcm9udC9uZy9wb3BvdmVyJztcbmltcG9ydCB7IG1lcmdlLCBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBkZWxheSwgbWFwLCBzdGFydFdpdGgsIHN3aXRjaE1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IEFMdVRyZWVPcHRpb25JdGVtIH0gZnJvbSAnLi4vaXRlbS9pbmRleCc7XG5pbXBvcnQgeyBBTHVPcHRpb25QaWNrZXJDb21wb25lbnQgfSBmcm9tICcuL29wdGlvbi1waWNrZXIuY29tcG9uZW50JztcbmltcG9ydCB7IElMdVRyZWVPcHRpb25QaWNrZXJQYW5lbCB9IGZyb20gJy4vdHJlZS1vcHRpb24tcGlja2VyLm1vZGVsJztcblxuZW51bSBUb2dnbGVNb2RlIHtcblx0YWxsLFxuXHRzZWxmLFxuXHRjaGlsZHJlbixcbn1cblxuQERpcmVjdGl2ZSgpXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQUx1VHJlZU9wdGlvblBpY2tlckNvbXBvbmVudDxULCBPIGV4dGVuZHMgaW1wb3J0KCcuLi9pdGVtL3RyZWUtb3B0aW9uLWl0ZW0ubW9kZWwnKS5JTHVUcmVlT3B0aW9uSXRlbTxUPiA9IGltcG9ydCgnLi4vaXRlbS90cmVlLW9wdGlvbi1pdGVtLm1vZGVsJykuSUx1VHJlZU9wdGlvbkl0ZW08VD4+XG5cdGV4dGVuZHMgQUx1T3B0aW9uUGlja2VyQ29tcG9uZW50PFQsIE8+XG5cdGltcGxlbWVudHMgSUx1VHJlZU9wdGlvblBpY2tlclBhbmVsPFQ+LCBPbkRlc3Ryb3ksIEFmdGVyVmlld0luaXRcbntcblx0QENvbnRlbnRDaGlsZHJlbihBTHVUcmVlT3B0aW9uSXRlbSwgeyBkZXNjZW5kYW50czogdHJ1ZSB9KVxuXHRvdmVycmlkZSBzZXQgb3B0aW9uc1FMKHFsOiBRdWVyeUxpc3Q8Tz4pIHtcblx0XHR0aGlzLl9vcHRpb25zUUwgPSBxbDtcblx0fVxuXHRAQ29udGVudENoaWxkcmVuKEFMdVRyZWVPcHRpb25JdGVtLCB7XG5cdFx0ZGVzY2VuZGFudHM6IHRydWUsXG5cdFx0cmVhZDogVmlld0NvbnRhaW5lclJlZixcblx0fSlcblx0b3B0aW9uc1FMVlI6IFF1ZXJ5TGlzdDxWaWV3Q29udGFpbmVyUmVmPjtcblx0cHJvdGVjdGVkIG92ZXJyaWRlIHNldCBfb3B0aW9ucyQob3B0aW9uSXRlbXMkOiBPYnNlcnZhYmxlPE9bXT4pIHtcblx0XHQvLyByZWFwcGx5IHNlbGVjdGVkIHdoZW4gdGhlIG9wdGlvbnMgY2hhbmdlXG5cdFx0dGhpcy5fc3Vicy5hZGQob3B0aW9uSXRlbXMkLnN1YnNjcmliZSgoKSA9PiB0aGlzLl9hcHBseVNlbGVjdGVkKCkpKTtcblx0XHQvLyBzdWJzY3JpYmUgdG8gYW55IG9wdGlvbi5vblNlbGVjdFxuXHRcdGNvbnN0IHNpbmdsZUZsb3dTZWxlY3QkID0gb3B0aW9uSXRlbXMkLnBpcGUoc3dpdGNoTWFwKChpdGVtcykgPT4gbWVyZ2UoLi4uaXRlbXMubWFwKChpKSA9PiBpLm9uU2VsZWN0KSkpKTtcblx0XHRjb25zdCBzaW5nbGVGbG93U2VsZWN0U2VsZiQgPSBvcHRpb25JdGVtcyQucGlwZShzd2l0Y2hNYXAoKGl0ZW1zKSA9PiBtZXJnZSguLi5pdGVtcy5tYXAoKGkpID0+IGkub25TZWxlY3RTZWxmKSkpKTtcblx0XHRjb25zdCBzaW5nbGVGbG93U2VsZWN0Q2hpbGRyZW4kID0gb3B0aW9uSXRlbXMkLnBpcGUoc3dpdGNoTWFwKChpdGVtcykgPT4gbWVyZ2UoLi4uaXRlbXMubWFwKChpKSA9PiBpLm9uU2VsZWN0Q2hpbGRyZW4pKSkpO1xuXG5cdFx0dGhpcy5fc3Vicy5hZGQoc2luZ2xlRmxvd1NlbGVjdCQuc3Vic2NyaWJlKChvcHRpb24pID0+IHRoaXMuX3RvZ2dsZShvcHRpb24sIFRvZ2dsZU1vZGUuYWxsKSkpO1xuXHRcdHRoaXMuX3N1YnMuYWRkKHNpbmdsZUZsb3dTZWxlY3RTZWxmJC5zdWJzY3JpYmUoKG9wdGlvbikgPT4gdGhpcy5fdG9nZ2xlKG9wdGlvbiwgVG9nZ2xlTW9kZS5zZWxmKSkpO1xuXHRcdHRoaXMuX3N1YnMuYWRkKHNpbmdsZUZsb3dTZWxlY3RDaGlsZHJlbiQuc3Vic2NyaWJlKChvcHRpb24pID0+IHRoaXMuX3RvZ2dsZShvcHRpb24sIFRvZ2dsZU1vZGUuY2hpbGRyZW4pKSk7XG5cdH1cblx0Y29uc3RydWN0b3IoX2NoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZiwgQEluamVjdChET0NVTUVOVCkgZG9jdW1lbnQ6IERvY3VtZW50KSB7XG5cdFx0c3VwZXIoX2NoYW5nZURldGVjdG9yUmVmLCBkb2N1bWVudCk7XG5cdH1cblx0cHJvdGVjdGVkIG92ZXJyaWRlIF90b2dnbGUob3B0aW9uOiBPLCBtb2QgPSBUb2dnbGVNb2RlLmFsbCkge1xuXHRcdHN3aXRjaCAobW9kKSB7XG5cdFx0XHRjYXNlIFRvZ2dsZU1vZGUuc2VsZjpcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3RvZ2dsZVNlbGYob3B0aW9uKTtcblx0XHRcdGNhc2UgVG9nZ2xlTW9kZS5jaGlsZHJlbjpcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3RvZ2dsZUNoaWxkcmVuKG9wdGlvbik7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fdG9nZ2xlQWxsKG9wdGlvbik7XG5cdFx0fVxuXHR9XG5cdHByb3RlY3RlZCBfdG9nZ2xlQWxsKG9wdGlvbjogTykge1xuXHRcdGNvbnN0IHZhbHVlID0gb3B0aW9uLnZhbHVlO1xuXHRcdGlmICghdGhpcy5tdWx0aXBsZSkge1xuXHRcdFx0dGhpcy5fc2VsZWN0KHZhbHVlKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0Y29uc3QgYWxsQ2hpbGRyZW4gPSBvcHRpb24uYWxsQ2hpbGRyZW4ubWFwKChpKSA9PiBpLnZhbHVlKTtcblx0XHRjb25zdCB2YWx1ZXMgPSA8VFtdPnRoaXMuX3ZhbHVlIHx8IFtdO1xuXHRcdGxldCBuZXdWYWx1ZXM6IFRbXTtcblx0XHRjb25zdCBzZWxmU2VsZWN0ZWQgPSB2YWx1ZXMuc29tZSgodikgPT4gdGhpcy5vcHRpb25Db21wYXJlcih2LCB2YWx1ZSkpO1xuXHRcdGNvbnN0IGFsbENoaWxkcmVuU2VsZWN0ZWQgPSBhbGxDaGlsZHJlbi5ldmVyeSgoY2hpbGQpID0+IHZhbHVlcy5zb21lKCh2KSA9PiB0aGlzLm9wdGlvbkNvbXBhcmVyKHYsIGNoaWxkKSkpO1xuXHRcdGlmIChzZWxmU2VsZWN0ZWQgJiYgYWxsQ2hpbGRyZW5TZWxlY3RlZCkge1xuXHRcdFx0Ly8gcmVtb3ZlIG9wdGlvbiBhbmQgaXRzIGNoaWxkcmVuXG5cdFx0XHRuZXdWYWx1ZXMgPSB0aGlzLl9yZW1vdmUodmFsdWVzLCBbdmFsdWUsIC4uLmFsbENoaWxkcmVuXSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGFkZCBvcHRpb24gYW5kIGl0cyBjaGlsZHJlblxuXHRcdFx0bmV3VmFsdWVzID0gdGhpcy5fYWRkKHZhbHVlcywgW3ZhbHVlLCAuLi5hbGxDaGlsZHJlbl0pO1xuXHRcdH1cblx0XHR0aGlzLl9zZWxlY3QobmV3VmFsdWVzKTtcblx0fVxuXHRwcm90ZWN0ZWQgX3RvZ2dsZVNlbGYob3B0aW9uOiBPKSB7XG5cdFx0Y29uc3QgdmFsdWUgPSBvcHRpb24udmFsdWU7XG5cdFx0aWYgKCF0aGlzLm11bHRpcGxlKSB7XG5cdFx0XHR0aGlzLl9zZWxlY3QodmFsdWUpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRjb25zdCBhbGxDaGlsZHJlbiA9IG9wdGlvbi5hbGxDaGlsZHJlbi5tYXAoKGkpID0+IGkudmFsdWUpO1xuXHRcdGNvbnN0IHZhbHVlcyA9IDxUW10+dGhpcy5fdmFsdWUgfHwgW107XG5cdFx0Y29uc3Qgc2VsZlNlbGVjdGVkID0gdmFsdWVzLnNvbWUoKHYpID0+IHRoaXMub3B0aW9uQ29tcGFyZXIodiwgdmFsdWUpKTtcblx0XHRjb25zdCBzb21lQ2hpbGRTZWxlY3RlZCA9IGFsbENoaWxkcmVuLnNvbWUoKGNoaWxkKSA9PiB2YWx1ZXMuc29tZSgodikgPT4gdGhpcy5vcHRpb25Db21wYXJlcih2LCBjaGlsZCkpKTtcblxuXHRcdGxldCBuZXdWYWx1ZXMgPSB0aGlzLl9yZW1vdmUodmFsdWVzLCBbLi4uYWxsQ2hpbGRyZW5dKTtcblx0XHRpZiAoc2VsZlNlbGVjdGVkICYmICFzb21lQ2hpbGRTZWxlY3RlZCkge1xuXHRcdFx0Ly8gcmVtb3ZlIG9wdGlvblxuXHRcdFx0bmV3VmFsdWVzID0gdGhpcy5fcmVtb3ZlKG5ld1ZhbHVlcywgW3ZhbHVlXSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGFkZCBvcHRpb25cblx0XHRcdG5ld1ZhbHVlcyA9IHRoaXMuX2FkZChuZXdWYWx1ZXMsIFt2YWx1ZV0pO1xuXHRcdH1cblx0XHR0aGlzLl9zZWxlY3QobmV3VmFsdWVzKTtcblx0fVxuXHRwcm90ZWN0ZWQgX3RvZ2dsZUNoaWxkcmVuKG9wdGlvbjogTykge1xuXHRcdGNvbnN0IHZhbHVlID0gb3B0aW9uLnZhbHVlO1xuXHRcdGlmICghdGhpcy5tdWx0aXBsZSkge1xuXHRcdFx0dGhpcy5fc2VsZWN0KHZhbHVlKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0Y29uc3QgYWxsQ2hpbGRyZW4gPSBvcHRpb24uYWxsQ2hpbGRyZW4ubWFwKChpKSA9PiBpLnZhbHVlKTtcblx0XHRjb25zdCB2YWx1ZXMgPSA8VFtdPnRoaXMuX3ZhbHVlIHx8IFtdO1xuXHRcdGNvbnN0IHNlbGZTZWxlY3RlZCA9IHZhbHVlcy5zb21lKCh2KSA9PiB0aGlzLm9wdGlvbkNvbXBhcmVyKHYsIHZhbHVlKSk7XG5cdFx0bGV0IG5ld1ZhbHVlcyA9IHRoaXMuX3JlbW92ZSh2YWx1ZXMsIFt2YWx1ZV0pO1xuXHRcdGNvbnN0IGFsbENoaWxkcmVuU2VsZWN0ZWQgPSBhbGxDaGlsZHJlbi5ldmVyeSgoY2hpbGQpID0+IHZhbHVlcy5zb21lKCh2KSA9PiB0aGlzLm9wdGlvbkNvbXBhcmVyKHYsIGNoaWxkKSkpO1xuXHRcdGlmIChhbGxDaGlsZHJlblNlbGVjdGVkICYmICFzZWxmU2VsZWN0ZWQpIHtcblx0XHRcdG5ld1ZhbHVlcyA9IHRoaXMuX3JlbW92ZShuZXdWYWx1ZXMsIGFsbENoaWxkcmVuKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bmV3VmFsdWVzID0gdGhpcy5fYWRkKG5ld1ZhbHVlcywgYWxsQ2hpbGRyZW4pO1xuXHRcdH1cblx0XHR0aGlzLl9zZWxlY3QobmV3VmFsdWVzKTtcblx0fVxuXHRwcm90ZWN0ZWQgX2FkZCh2YWx1ZXM6IFRbXSwgZW50cmllczogVFtdKTogVFtdIHtcblx0XHRjb25zdCBuZXdFbnRyaWVzID0gZW50cmllcy5maWx0ZXIoKGVudHJ5KSA9PiAhdmFsdWVzLnNvbWUoKHYpID0+IHRoaXMub3B0aW9uQ29tcGFyZXIodiwgZW50cnkpKSk7XG5cdFx0cmV0dXJuIFsuLi52YWx1ZXMsIC4uLm5ld0VudHJpZXNdO1xuXHR9XG5cdHByb3RlY3RlZCBfcmVtb3ZlKHZhbHVlczogVFtdLCBlbnRyaWVzOiBUW10pOiBUW10ge1xuXHRcdGNvbnN0IGVudHJpZXNUb0tlZXAgPSB2YWx1ZXMuZmlsdGVyKCh2YWx1ZSkgPT4gIWVudHJpZXMuc29tZSgoZSkgPT4gdGhpcy5vcHRpb25Db21wYXJlcihlLCB2YWx1ZSkpKTtcblx0XHRyZXR1cm4gWy4uLmVudHJpZXNUb0tlZXBdO1xuXHR9XG5cblx0cHJvdGVjdGVkIG92ZXJyaWRlIGluaXRJdGVtcygpIHtcblx0XHRjb25zdCBpdGVtcyQgPSB0aGlzLl9vcHRpb25zUUwuY2hhbmdlcy5waXBlKFxuXHRcdFx0c3RhcnRXaXRoKHRoaXMuX29wdGlvbnNRTCksXG5cdFx0XHRtYXA8UXVlcnlMaXN0PE8+LCBPW10+KChxKSA9PiBxLnRvQXJyYXkoKSksXG5cdFx0XHRtYXAoKHJvb3RzKSA9PiByb290cy5tYXAoKHIpID0+IFtyLCAuLi5yLmFsbENoaWxkcmVuXSkucmVkdWNlKChhZ2csIHZhbCkgPT4gWy4uLmFnZywgLi4udmFsXSwgW10pKSxcblx0XHRcdGRlbGF5KDApLFxuXHRcdCk7XG5cdFx0dGhpcy5fc3Vicy5hZGQoaXRlbXMkLnN1YnNjcmliZSgobykgPT4gKHRoaXMuX29wdGlvbnMgPSBvIHx8IFtdKSkpO1xuXHRcdHRoaXMuX29wdGlvbnMkID0gaXRlbXMkO1xuXHR9XG5cdG92ZXJyaWRlIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcblx0XHR0aGlzLmluaXRJdGVtcygpO1xuXHR9XG59XG4vKipcbiAqIGJhc2ljIHRyZWUgb3B0aW9uIHBpY2tlciBwYW5lbFxuICovXG5AQ29tcG9uZW50KHtcblx0c2VsZWN0b3I6ICdsdS10cmVlLW9wdGlvbi1waWNrZXInLFxuXHR0ZW1wbGF0ZVVybDogJy4vdHJlZS1vcHRpb24tcGlja2VyLmNvbXBvbmVudC5odG1sJyxcblx0Y2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG5cdGFuaW1hdGlvbnM6IFtsdVRyYW5zZm9ybVBvcG92ZXJdLFxuXHRleHBvcnRBczogJ0x1VHJlZU9wdGlvblBpY2tlcicsXG5cdHN0YW5kYWxvbmU6IHRydWUsXG5cdGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIEExMXlNb2R1bGVdLFxuXHRwcm92aWRlcnM6IFtcblx0XHR7XG5cdFx0XHRwcm92aWRlOiBBTHVQaWNrZXJQYW5lbCxcblx0XHRcdHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IEx1VHJlZU9wdGlvblBpY2tlckNvbXBvbmVudCksXG5cdFx0fSxcblx0XSxcbn0pXG5leHBvcnQgY2xhc3MgTHVUcmVlT3B0aW9uUGlja2VyQ29tcG9uZW50PFxuXHRULFxuXHRPIGV4dGVuZHMgaW1wb3J0KCcuLi9pdGVtL3RyZWUtb3B0aW9uLWl0ZW0ubW9kZWwnKS5JTHVUcmVlT3B0aW9uSXRlbTxUPiA9IGltcG9ydCgnLi4vaXRlbS90cmVlLW9wdGlvbi1pdGVtLm1vZGVsJykuSUx1VHJlZU9wdGlvbkl0ZW08VD4sXG4+IGV4dGVuZHMgQUx1VHJlZU9wdGlvblBpY2tlckNvbXBvbmVudDxULCBPPiB7XG5cdGNvbnN0cnVjdG9yKF9jaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsIEBJbmplY3QoRE9DVU1FTlQpIGRvY3VtZW50OiBEb2N1bWVudCkge1xuXHRcdHN1cGVyKF9jaGFuZ2VEZXRlY3RvclJlZiwgZG9jdW1lbnQpO1xuXHR9XG59XG4iLCI8bmctdGVtcGxhdGU+XG5cdDxkaXZcblx0XHRjbGFzcz1cImx1LXBpY2tlci1wYW5lbCBsdS10cmVlLW9wdGlvbi1waWNrZXItcGFuZWxcIlxuXHRcdHJvbGU9XCJkaWFsb2dcIlxuXHRcdFtuZ0NsYXNzXT1cInBhbmVsQ2xhc3Nlc01hcFwiXG5cdFx0W2NsYXNzLm1vZC1tdWx0aXBsZV09XCJtdWx0aXBsZVwiXG5cdFx0KGNsaWNrKT1cIm9uQ2xpY2soKVwiXG5cdFx0KG1vdXNlb3Zlcik9XCJvbk1vdXNlT3ZlcigpXCJcblx0XHQobW91c2VsZWF2ZSk9XCJvbk1vdXNlTGVhdmUoKVwiXG5cdFx0KG1vdXNlZG93bik9XCJvbk1vdXNlRG93bigpXCJcblx0PlxuXHRcdDxkaXYgY2xhc3M9XCJsdS1waWNrZXItY29udGVudFwiIFtuZ0NsYXNzXT1cImNvbnRlbnRDbGFzc2VzTWFwXCIgW2Nka1RyYXBGb2N1c109XCJ0cmFwRm9jdXNcIj5cblx0XHRcdDxkaXYgY2xhc3M9XCJsdS1waWNrZXItY29udGVudC1vcHRpb25cIj5cblx0XHRcdFx0PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuXHRcdFx0PC9kaXY+XG5cdFx0PC9kaXY+XG5cdDwvZGl2PlxuPC9uZy10ZW1wbGF0ZT5cbiJdfQ==