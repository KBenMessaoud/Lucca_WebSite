import * as i0 from '@angular/core';
import { Directive, Input, InjectionToken, inject, Component, ViewContainerRef, Injector, TemplateRef, ChangeDetectorRef, ElementRef, ChangeDetectionStrategy, HostBinding, ViewChild, EventEmitter, Output, HostListener, Injectable } from '@angular/core';
import { OverlayContainer, Overlay } from '@angular/cdk/overlay';
import { BehaviorSubject, observeOn, asyncScheduler, ReplaySubject, Subject } from 'rxjs';
import { AsyncPipe, NgIf, DOCUMENT } from '@angular/common';
import { Platform } from '@angular/cdk/platform';

class LuDisplayerDirective {
    set select(select) {
        select.valueTpl = this.templateRef;
    }
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ngTemplateContextGuard(_dir, ctx) {
        return true;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.3", ngImport: i0, type: LuDisplayerDirective, deps: [{ token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.1.3", type: LuDisplayerDirective, isStandalone: true, selector: "[luDisplayer]", inputs: { select: ["luDisplayerSelect", "select"] }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.3", ngImport: i0, type: LuDisplayerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[luDisplayer]',
                    standalone: true,
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef }]; }, propDecorators: { select: [{
                type: Input,
                args: ['luDisplayerSelect']
            }] } });

const LU_OPTION_CONTEXT = new InjectionToken('LuOptionContext');
function optionContextFactory() {
    const isDisabled$ = new BehaviorSubject(false);
    const option$ = new BehaviorSubject(undefined);
    return {
        isDisabled$,
        option$,
        destroy() {
            isDisabled$.complete();
            option$.complete();
        },
    };
}
function provideOptionContext() {
    return {
        provide: LU_OPTION_CONTEXT,
        useFactory: optionContextFactory,
    };
}

class LuSimpleSelectDefaultOptionComponent {
    constructor() {
        this.context = inject(LU_OPTION_CONTEXT);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.3", ngImport: i0, type: LuSimpleSelectDefaultOptionComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.1.3", type: LuSimpleSelectDefaultOptionComponent, isStandalone: true, selector: "lu-simple-select-default-option", ngImport: i0, template: `<ng-container *ngIf="context.option$ | async as option">{{ option?.name ?? option }}</ng-container>`, isInline: true, dependencies: [{ kind: "pipe", type: AsyncPipe, name: "async" }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.3", ngImport: i0, type: LuSimpleSelectDefaultOptionComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'lu-simple-select-default-option',
                    standalone: true,
                    imports: [AsyncPipe, NgIf],
                    template: `<ng-container *ngIf="context.option$ | async as option">{{ option?.name ?? option }}</ng-container>`,
                }]
        }] });

class LuDisabledOptionDirective {
    constructor() {
        this.context = inject(LU_OPTION_CONTEXT);
    }
    set isDisabled(disabled) {
        if (disabled !== null) {
            this.context.isDisabled$.next(disabled);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.3", ngImport: i0, type: LuDisabledOptionDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.1.3", type: LuDisabledOptionDirective, isStandalone: true, selector: "[luDisabledOption]", inputs: { isDisabled: ["luDisabledOption", "isDisabled"] }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.3", ngImport: i0, type: LuDisabledOptionDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[luDisabledOption]',
                    standalone: true,
                }]
        }], propDecorators: { isDisabled: [{
                type: Input,
                args: ['luDisabledOption']
            }] } });

class LuOptionOutletDirective {
    constructor() {
        this.viewContainerRef = inject(ViewContainerRef);
        this.injector = inject(Injector);
        this.optionContext = inject(LU_OPTION_CONTEXT);
    }
    ngOnChanges(changes) {
        if (changes['luOptionOutlet'] || !this.luOptionOutletValue) {
            this.clearContainer();
        }
        const hasRef = this.embeddedViewRef || this.componentRef;
        if (changes['luOptionOutlet'] || (changes['luOptionOutletValue'] && !hasRef)) {
            this.createComponent();
        }
        else if (changes['luOptionOutletValue']) {
            this.updateRefValue();
        }
    }
    ngOnDestroy() {
        this.optionContext.destroy();
    }
    clearContainer() {
        this.viewContainerRef.clear();
        this.embeddedViewRef?.destroy();
        this.componentRef?.destroy();
        this.embeddedViewRef = undefined;
        this.componentRef = undefined;
    }
    createComponent() {
        if (!this.luOptionOutlet || !this.luOptionOutletValue) {
            return;
        }
        if (this.luOptionOutlet instanceof TemplateRef) {
            this.embeddedViewRef = this.viewContainerRef.createEmbeddedView(this.luOptionOutlet, { $implicit: this.luOptionOutletValue }, { injector: this.injector });
        }
        else {
            this.optionContext.option$.next(this.luOptionOutletValue);
            this.componentRef = this.viewContainerRef.createComponent(this.luOptionOutlet, { injector: this.injector });
        }
    }
    updateRefValue() {
        if (!this.luOptionOutletValue) {
            return;
        }
        if (this.embeddedViewRef) {
            this.embeddedViewRef.context = { $implicit: this.luOptionOutletValue };
        }
        else if (this.componentRef) {
            this.optionContext.option$.next(this.luOptionOutletValue);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.3", ngImport: i0, type: LuOptionOutletDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.1.3", type: LuOptionOutletDirective, isStandalone: true, selector: "[luOptionOutlet]", inputs: { luOptionOutlet: "luOptionOutlet", luOptionOutletValue: "luOptionOutletValue" }, providers: [provideOptionContext()], usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.3", ngImport: i0, type: LuOptionOutletDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[luOptionOutlet]',
                    standalone: true,
                    providers: [provideOptionContext()],
                }]
        }], propDecorators: { luOptionOutlet: [{
                type: Input
            }], luOptionOutletValue: [{
                type: Input
            }] } });

const SELECT_ID = new InjectionToken('LuSelectPanelData');
const SELECT_LABEL = new InjectionToken('LuSelectLabel');
const SELECT_LABEL_ID = new InjectionToken('LuSelectLabelId');

class LuOptionComponent {
    constructor() {
        this.hasOptionItemClass = true;
        this.isSelected = false;
        this.optionIndex = 0;
        this.scrollIntoViewOptions = {};
        this.isHighlighted$ = new BehaviorSubject(false);
        /**
         * Whether option is disabled. Used by ListKeyManager.
         */
        this.disabled = false;
        this.cdr = inject(ChangeDetectorRef);
        this.role = 'option';
        this.elementRef = inject(ElementRef);
        this.selectId = inject(SELECT_ID);
    }
    get id() {
        return `lu-select-${this.selectId}-option-${this.optionIndex}`;
    }
    ngOnDestroy() {
        this.subscription?.unsubscribe();
    }
    ngAfterViewInit() {
        this.subscription = this.optionContext.isDisabled$.pipe(observeOn(asyncScheduler)).subscribe((isDisabled) => {
            this.disabled = isDisabled;
            this.cdr.markForCheck();
        });
    }
    setActiveStyles() {
        this.isHighlighted$.next(true);
        this.elementRef.nativeElement.scrollIntoView(this.scrollIntoViewOptions);
    }
    setInactiveStyles() {
        this.isHighlighted$.next(false);
    }
    selectOption($event) {
        if (this.disabled) {
            $event.stopPropagation();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.3", ngImport: i0, type: LuOptionComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.1.3", type: LuOptionComponent, isStandalone: true, selector: "lu-select-option", inputs: { optionTpl: "optionTpl", isSelected: "isSelected", option: "option", optionIndex: "optionIndex", scrollIntoViewOptions: "scrollIntoViewOptions" }, host: { properties: { "class.optionItem": "this.hasOptionItemClass", "attr.aria-selected": "this.isSelected", "attr.role": "this.role", "attr.id": "this.id" } }, viewQueries: [{ propertyName: "optionContext", first: true, predicate: LuOptionOutletDirective, descendants: true, read: LU_OPTION_CONTEXT, static: true }], ngImport: i0, template: "<div\n\tclass=\"optionItem-value\"\n\t[class.is-selected]=\"isSelected\"\n\t[class.is-highlighted]=\"isHighlighted$ | async\"\n\t[class.is-disabled]=\"disabled\"\n\t(click)=\"selectOption($event)\"\n>\n\t<ng-container *luOptionOutlet=\"optionTpl; value: option\"></ng-container>\n</div>\n", styles: [":root{--components-options-item-padding-vertical: var(--spacings-XS);--components-options-item-padding-horizontal: var(--spacings-XS);--components-options-item-multiple-padding: 2.25rem;--components-options-item-icon-color: var(--palettes-grey-800);--components-options-checkbox-left: .5rem;--components-options-checkbox-size: 1.25rem;--components-options-checkbox-color: var(--palettes-primary-700);--components-options-checkbox-border-radius: 6px;--components-options-checkbox-border-color: var(--palettes-grey-700);--components-options-establishment-multiple-padding: 2rem}:host{display:block}.optionItem{position:relative}.optionItem-value{border-radius:var(--commons-borderRadius-M);display:block;padding:var(--components-options-item-padding-vertical) var(--components-options-item-padding-horizontal);transition:background-color 50ms;cursor:pointer}.optionItem-value.is-selected{background-color:var(--palettes-primary-50)}.optionItem-value.is-selected:hover{background-color:var(--palettes-primary-100)}.optionItem-value.is-selected:active{background-color:var(--palettes-primary-200)}.optionItem-value.is-selected.is-highlighted{background-color:var(--palettes-primary-100)}.optionItem-value.is-selected.is-highlighted:hover{background-color:var(--palettes-primary-200)}.optionItem-value:hover,.optionItem-value.is-highlighted,.optionItem-value.is-focus,.optionItem-value.is-highlighted:hover,.optionItem-value.is-focus:hover{background-color:var(--palettes-grey-50)}.optionItem-value.is-highlighted:active,.optionItem-value.is-focus:active,.optionItem-value:active{background-color:var(--palettes-grey-100)}:host-context(.lu-select-value) .optionItem-value{padding:0;overflow:hidden;text-overflow:ellipsis}:host-context(.lu-select-value) .optionItem-value:hover,:host-context(.lu-select-value) .optionItem-value.is-focus,:host-context(.lu-select-value) .optionItem-value.is-highlighted{background-color:inherit}:host-context(.mod-multiple) .optionItem-value{position:relative;padding-left:var(--components-options-item-multiple-padding)}:host-context(.mod-multiple) .optionItem-value:after,:host-context(.mod-multiple) .optionItem-value:before{display:block;position:absolute;left:var(--components-options-checkbox-left);top:50%;transform:translateY(-50%)}:host-context(.mod-multiple) .optionItem-value:before{content:\"\";border-radius:var(--components-options-checkbox-border-radius);box-shadow:inset 0 0 0 2px var(--components-options-checkbox-border-color);display:block;height:var(--components-options-checkbox-size);transition-property:background-color,box-shadow;transition-duration:var(--commons-animations-durations-fast);width:var(--components-options-checkbox-size)}:host-context(.mod-multiple) .optionItem-value:after{display:inline-block;vertical-align:text-bottom;font-style:normal;font-family:Lucca icons;color:transparent;font-size:var(--sizes-S-lineHeight);line-height:var(--components-options-checkbox-size);position:absolute;text-align:center;transform:translateY(-50%) scale(0);transition:all .1s;width:var(--components-options-checkbox-size)}@supports (content: \"*\"/\"\"){:host-context(.mod-multiple) .optionItem-value:after{content:\"\\e97d\"/\"\"}}@supports not (content: \"*\"/\"\"){:host-context(.mod-multiple) .optionItem-value:after{content:\"\\e97d\"}}:host-context(.mod-multiple) .optionItem-value.is-selected:before{background-color:var(--components-options-checkbox-color);box-shadow:inset 0 0 0 2px var(--components-options-checkbox-color)}:host-context(.mod-multiple) .optionItem-value.is-selected:after{color:var(--colors-white-color);transform:translateY(-50%) scale(1)}:host-context(.mod-multiple) .optionItem-value.is-disabled{--components-options-checkbox-border-color: var(--palettes-grey-500)}:host-context(.mod-multiple) .optionItem-value:not(.is-disabled):hover:before{box-shadow:inset 0 0 0 2px var(--components-options-checkbox-color)}:host-context(.mod-multiple).establishmentOption .optionItem-value{position:relative;padding-left:calc(var(--components-options-checkbox-size) + var(--spacings-XS) * 2)}:host-context(.mod-multiple).establishmentOption .optionItem-value:before,:host-context(.mod-multiple).establishmentOption .optionItem-value:after{left:var(--spacings-XS)}.is-disabled{color:var(--palettes-grey-500);-webkit-user-select:none;user-select:none;cursor:default}.is-disabled.is-selected{background-color:var(--palettes-grey-100)}.is-disabled:hover{background-color:inherit}\n"], dependencies: [{ kind: "pipe", type: AsyncPipe, name: "async" }, { kind: "directive", type: LuOptionOutletDirective, selector: "[luOptionOutlet]", inputs: ["luOptionOutlet", "luOptionOutletValue"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.3", ngImport: i0, type: LuOptionComponent, decorators: [{
            type: Component,
            args: [{ selector: 'lu-select-option', changeDetection: ChangeDetectionStrategy.OnPush, standalone: true, imports: [AsyncPipe, LuOptionOutletDirective], template: "<div\n\tclass=\"optionItem-value\"\n\t[class.is-selected]=\"isSelected\"\n\t[class.is-highlighted]=\"isHighlighted$ | async\"\n\t[class.is-disabled]=\"disabled\"\n\t(click)=\"selectOption($event)\"\n>\n\t<ng-container *luOptionOutlet=\"optionTpl; value: option\"></ng-container>\n</div>\n", styles: [":root{--components-options-item-padding-vertical: var(--spacings-XS);--components-options-item-padding-horizontal: var(--spacings-XS);--components-options-item-multiple-padding: 2.25rem;--components-options-item-icon-color: var(--palettes-grey-800);--components-options-checkbox-left: .5rem;--components-options-checkbox-size: 1.25rem;--components-options-checkbox-color: var(--palettes-primary-700);--components-options-checkbox-border-radius: 6px;--components-options-checkbox-border-color: var(--palettes-grey-700);--components-options-establishment-multiple-padding: 2rem}:host{display:block}.optionItem{position:relative}.optionItem-value{border-radius:var(--commons-borderRadius-M);display:block;padding:var(--components-options-item-padding-vertical) var(--components-options-item-padding-horizontal);transition:background-color 50ms;cursor:pointer}.optionItem-value.is-selected{background-color:var(--palettes-primary-50)}.optionItem-value.is-selected:hover{background-color:var(--palettes-primary-100)}.optionItem-value.is-selected:active{background-color:var(--palettes-primary-200)}.optionItem-value.is-selected.is-highlighted{background-color:var(--palettes-primary-100)}.optionItem-value.is-selected.is-highlighted:hover{background-color:var(--palettes-primary-200)}.optionItem-value:hover,.optionItem-value.is-highlighted,.optionItem-value.is-focus,.optionItem-value.is-highlighted:hover,.optionItem-value.is-focus:hover{background-color:var(--palettes-grey-50)}.optionItem-value.is-highlighted:active,.optionItem-value.is-focus:active,.optionItem-value:active{background-color:var(--palettes-grey-100)}:host-context(.lu-select-value) .optionItem-value{padding:0;overflow:hidden;text-overflow:ellipsis}:host-context(.lu-select-value) .optionItem-value:hover,:host-context(.lu-select-value) .optionItem-value.is-focus,:host-context(.lu-select-value) .optionItem-value.is-highlighted{background-color:inherit}:host-context(.mod-multiple) .optionItem-value{position:relative;padding-left:var(--components-options-item-multiple-padding)}:host-context(.mod-multiple) .optionItem-value:after,:host-context(.mod-multiple) .optionItem-value:before{display:block;position:absolute;left:var(--components-options-checkbox-left);top:50%;transform:translateY(-50%)}:host-context(.mod-multiple) .optionItem-value:before{content:\"\";border-radius:var(--components-options-checkbox-border-radius);box-shadow:inset 0 0 0 2px var(--components-options-checkbox-border-color);display:block;height:var(--components-options-checkbox-size);transition-property:background-color,box-shadow;transition-duration:var(--commons-animations-durations-fast);width:var(--components-options-checkbox-size)}:host-context(.mod-multiple) .optionItem-value:after{display:inline-block;vertical-align:text-bottom;font-style:normal;font-family:Lucca icons;color:transparent;font-size:var(--sizes-S-lineHeight);line-height:var(--components-options-checkbox-size);position:absolute;text-align:center;transform:translateY(-50%) scale(0);transition:all .1s;width:var(--components-options-checkbox-size)}@supports (content: \"*\"/\"\"){:host-context(.mod-multiple) .optionItem-value:after{content:\"\\e97d\"/\"\"}}@supports not (content: \"*\"/\"\"){:host-context(.mod-multiple) .optionItem-value:after{content:\"\\e97d\"}}:host-context(.mod-multiple) .optionItem-value.is-selected:before{background-color:var(--components-options-checkbox-color);box-shadow:inset 0 0 0 2px var(--components-options-checkbox-color)}:host-context(.mod-multiple) .optionItem-value.is-selected:after{color:var(--colors-white-color);transform:translateY(-50%) scale(1)}:host-context(.mod-multiple) .optionItem-value.is-disabled{--components-options-checkbox-border-color: var(--palettes-grey-500)}:host-context(.mod-multiple) .optionItem-value:not(.is-disabled):hover:before{box-shadow:inset 0 0 0 2px var(--components-options-checkbox-color)}:host-context(.mod-multiple).establishmentOption .optionItem-value{position:relative;padding-left:calc(var(--components-options-checkbox-size) + var(--spacings-XS) * 2)}:host-context(.mod-multiple).establishmentOption .optionItem-value:before,:host-context(.mod-multiple).establishmentOption .optionItem-value:after{left:var(--spacings-XS)}.is-disabled{color:var(--palettes-grey-500);-webkit-user-select:none;user-select:none;cursor:default}.is-disabled.is-selected{background-color:var(--palettes-grey-100)}.is-disabled:hover{background-color:inherit}\n"] }]
        }], propDecorators: { hasOptionItemClass: [{
                type: HostBinding,
                args: ['class.optionItem']
            }], optionTpl: [{
                type: Input
            }], isSelected: [{
                type: Input
            }, {
                type: HostBinding,
                args: ['attr.aria-selected']
            }], option: [{
                type: Input
            }], optionIndex: [{
                type: Input
            }], scrollIntoViewOptions: [{
                type: Input
            }], optionContext: [{
                type: ViewChild,
                args: [LuOptionOutletDirective, { read: LU_OPTION_CONTEXT, static: true }]
            }], role: [{
                type: HostBinding,
                args: ['attr.role']
            }], id: [{
                type: HostBinding,
                args: ['attr.id']
            }] } });

class LuOptionDirective {
    set select(select) {
        select.optionTpl = this.templateRef;
    }
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ngTemplateContextGuard(_dir, ctx) {
        return true;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.3", ngImport: i0, type: LuOptionDirective, deps: [{ token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.1.3", type: LuOptionDirective, isStandalone: true, selector: "[luOption]", inputs: { select: ["luOptionSelect", "select"] }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.3", ngImport: i0, type: LuOptionDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[luOption]',
                    standalone: true,
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef }]; }, propDecorators: { select: [{
                type: Input,
                args: ['luOptionSelect']
            }] } });

/* eslint-disable @angular-eslint/no-output-on-prefix */
class ALuSelectInputComponent {
    constructor() {
        this.tabindex = 0;
        this.placeholder = '';
        this.clearable = false;
        this.disabled = false;
        this.isPanelOpen$ = new BehaviorSubject(false);
        this.role = 'combobox';
        this.overlayConfig = {
            hasBackdrop: true,
            backdropClass: 'cdk-overlay-transparent-backdrop',
        };
        this.optionComparer = (option1, option2) => JSON.stringify(option1) === JSON.stringify(option2);
        this.optionTpl = LuSimpleSelectDefaultOptionComponent;
        this.clueChange = new EventEmitter();
        this.nextPage = new EventEmitter();
        this.previousPage = new EventEmitter();
        this.options$ = new ReplaySubject(1);
        this.loading$ = new ReplaySubject(1);
        this.clue = null;
        this.destroyed$ = new Subject();
        this.changeDetectorRef = inject(ChangeDetectorRef);
        this.overlayContainerRef = inject(OverlayContainer).getContainerElement();
        this.label = inject(SELECT_LABEL);
        this.labelId = inject(SELECT_LABEL_ID);
    }
    get searchable() {
        return this.clueChange.observed;
    }
    get isFilledClass() {
        return this.hasValue;
    }
    get isPanelOpen() {
        return this.isPanelOpen$.value;
    }
    get ariaControls() {
        return this.overlayContainerRef.id;
    }
    set loading(value) {
        this.loading$.next(value);
    }
    set options(options) {
        this.options$.next(options);
    }
    get value() {
        return this._value;
    }
    set value(value) {
        this._value = value;
        this.changeDetectorRef.markForCheck();
    }
    get panelRef() {
        return this._panelRef;
    }
    onKeydown($event) {
        if (!this.isPanelOpen) {
            this.openPanel();
            $event.stopPropagation();
            $event.preventDefault();
        }
    }
    registerOnChange(onChange) {
        this.onChange = onChange;
    }
    registerOnTouched(onTouched) {
        this.onTouched = onTouched;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    ngOnDestroy() {
        this.closePanel();
        this.destroyed$.next();
        this.destroyed$.complete();
    }
    ngOnInit() {
        if (this.label) {
            this.label.id = this.labelId;
        }
    }
    clearValue(event) {
        event.stopPropagation();
        this.updateValue(null);
    }
    openPanel() {
        if (this.isPanelOpen || this.disabled) {
            return;
        }
        this.isPanelOpen$.next(true);
        this._panelRef = this.buildPanelRef();
        this.bindInputToPanelRefEvents();
    }
    bindInputToPanelRefEvents() {
        if (!this.panelRef) {
            return;
        }
        this.panelRef.valueChanged.subscribe((value) => this.updateValue(value));
        this.panelRef.nextPage.subscribe(() => this.nextPage.emit());
        this.panelRef.previousPage.subscribe(() => this.previousPage.emit());
        this.panelRef.clueChanged.subscribe((clue) => {
            this.clueChange.emit(clue);
            this.clue = clue;
        });
        this.panelRef.activeOptionIdChanged.subscribe((optionId) => {
            this.activeDescendant = optionId;
            this.changeDetectorRef.markForCheck();
        });
        this.panelRef.closed.subscribe(() => this.closePanel());
    }
    closePanel() {
        if (!this.isPanelOpen) {
            return;
        }
        this.onTouched?.();
        this.isPanelOpen$.next(false);
        this.panelRef.close();
        this._panelRef = undefined;
    }
    writeValue(value) {
        this.value = value;
    }
    updateValue(value) {
        this.value = value;
        this.onChange?.(value);
        this.onTouched?.();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.3", ngImport: i0, type: ALuSelectInputComponent, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.1.3", type: ALuSelectInputComponent, inputs: { placeholder: "placeholder", clearable: "clearable", disabled: "disabled", overlayConfig: "overlayConfig", loading: "loading", options: "options", optionComparer: "optionComparer", optionTpl: "optionTpl", valueTpl: "valueTpl" }, outputs: { clueChange: "clueChange", nextPage: "nextPage", previousPage: "previousPage" }, host: { listeners: { "keydown.space": "onKeydown($event)", "keydown.enter": "onKeydown($event)", "keydown.arrowDown": "onKeydown($event)", "click": "onKeydown($event)" }, properties: { "tabindex": "this.tabindex", "class.is-clearable": "this.clearable", "class.is-disabled": "this.disabled", "class.is-filled": "this.isFilledClass", "class.is-focused": "this.isPanelOpen", "attr.aria-expanded": "this.isPanelOpen", "attr.role": "this.role", "attr.aria-activedescendant": "this.activeDescendant", "attr.aria-controls": "this.ariaControls" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.3", ngImport: i0, type: ALuSelectInputComponent, decorators: [{
            type: Directive
        }], propDecorators: { tabindex: [{
                type: HostBinding,
                args: ['tabindex']
            }], placeholder: [{
                type: Input
            }], clearable: [{
                type: Input
            }, {
                type: HostBinding,
                args: ['class.is-clearable']
            }], disabled: [{
                type: Input
            }, {
                type: HostBinding,
                args: ['class.is-disabled']
            }], isFilledClass: [{
                type: HostBinding,
                args: ['class.is-filled']
            }], isPanelOpen: [{
                type: HostBinding,
                args: ['class.is-focused']
            }, {
                type: HostBinding,
                args: ['attr.aria-expanded']
            }], role: [{
                type: HostBinding,
                args: ['attr.role']
            }], activeDescendant: [{
                type: HostBinding,
                args: ['attr.aria-activedescendant']
            }], ariaControls: [{
                type: HostBinding,
                args: ['attr.aria-controls']
            }], overlayConfig: [{
                type: Input
            }], loading: [{
                type: Input
            }], options: [{
                type: Input
            }], optionComparer: [{
                type: Input
            }], optionTpl: [{
                type: Input
            }], valueTpl: [{
                type: Input
            }], clueChange: [{
                type: Output
            }], nextPage: [{
                type: Output
            }], previousPage: [{
                type: Output
            }], onKeydown: [{
                type: HostListener,
                args: ['keydown.space', ['$event']]
            }, {
                type: HostListener,
                args: ['keydown.enter', ['$event']]
            }, {
                type: HostListener,
                args: ['keydown.arrowDown', ['$event']]
            }, {
                type: HostListener,
                args: ['click', ['$event']]
            }] } });

let selectId = 0;
function selectIdFactory() {
    return selectId++;
}
function selectLabelFactory() {
    const elementRef = inject(ElementRef);
    function getLabel(node) {
        if (node instanceof HTMLLabelElement) {
            return node;
        }
        if (!node.parentElement) {
            return undefined;
        }
        return getLabel(node.parentElement);
    }
    return getLabel(elementRef.nativeElement);
}
function selectLabelIdFactory() {
    return inject(SELECT_LABEL)?.id || `lu-select-label-${inject(SELECT_ID)}`;
}
function provideLuSelectLabelsAndIds() {
    return [
        { provide: SELECT_ID, useFactory: selectIdFactory },
        { provide: SELECT_LABEL, useFactory: selectLabelFactory },
        { provide: SELECT_LABEL_ID, useFactory: selectLabelIdFactory },
    ];
}
class LuSelectOverlayContainer extends OverlayContainer {
    constructor() {
        super(inject(DOCUMENT), inject(Platform));
        this.selectLabelId = inject(SELECT_LABEL_ID);
        this.selectId = inject(SELECT_ID);
    }
    _createContainer() {
        super._createContainer();
        this._containerElement.setAttribute('aria-labelledby', this.selectLabelId);
        this._containerElement.id = `lu-select-overlay-container-${this.selectId}`;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.3", ngImport: i0, type: LuSelectOverlayContainer, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.1.3", ngImport: i0, type: LuSelectOverlayContainer }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.3", ngImport: i0, type: LuSelectOverlayContainer, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return []; } });
function provideLuSelectOverlayContainer() {
    return [
        Overlay,
        {
            provide: OverlayContainer,
            useClass: LuSelectOverlayContainer,
        },
    ];
}

class LuSelectPanelRef {
    constructor() {
        this.closed = new EventEmitter();
        this.previousPage = new EventEmitter();
        this.nextPage = new EventEmitter();
        this.valueChanged = new EventEmitter();
        this.clueChanged = new EventEmitter();
        this.activeOptionIdChanged = new EventEmitter();
    }
    close() {
        this.closed.next();
        this.closed.complete();
        this.nextPage.complete();
        this.previousPage.complete();
        this.valueChanged.complete();
        this.clueChanged.emit('');
        this.clueChanged.complete();
        this.activeOptionIdChanged.emit(undefined);
        this.activeOptionIdChanged.complete();
    }
}

/**
 * Generated bundle index. Do not edit.
 */

export { ALuSelectInputComponent, LU_OPTION_CONTEXT, LuDisabledOptionDirective, LuDisplayerDirective, LuOptionDirective, LuSelectPanelRef, LuSimpleSelectDefaultOptionComponent, SELECT_ID, SELECT_LABEL, SELECT_LABEL_ID, provideLuSelectLabelsAndIds, provideLuSelectOverlayContainer, provideOptionContext, LuOptionComponent as ɵLuOptionComponent, LuOptionOutletDirective as ɵLuOptionOutletDirective };
//# sourceMappingURL=lucca-front-ng-core-select.mjs.map
