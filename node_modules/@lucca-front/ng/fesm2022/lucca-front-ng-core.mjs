import * as i0 from '@angular/core';
import { InjectionToken, LOCALE_ID, Injectable, Inject, Optional, inject, ViewContainerRef, Renderer2, TemplateRef, Directive, Input, IterableDiffers, KeyValueDiffers, ElementRef } from '@angular/core';
import { getLocaleDateFormat, FormatWidth, formatDate, NgClass } from '@angular/common';

var ELuDateGranularity;
(function (ELuDateGranularity) {
    ELuDateGranularity["day"] = "day";
    ELuDateGranularity["month"] = "month";
    ELuDateGranularity["year"] = "year";
    ELuDateGranularity["decade"] = "decade";
})(ELuDateGranularity || (ELuDateGranularity = {}));

class ALuDateAdapter {
    compare(a, b, granularity) {
        if (!a || !b || !this.isValid(a) || !this.isValid(b)) {
            throw new Error('you must provide valid and not null dates to be compared');
        }
        const aDecade = Math.floor(this.getYear(a) / 10);
        const bDecade = Math.floor(this.getYear(b) / 10);
        if (aDecade < bDecade) {
            return -1;
        }
        if (aDecade > bDecade) {
            return 1;
        }
        if (granularity === ELuDateGranularity.decade) {
            return 0;
        }
        const aYear = this.getYear(a);
        const bYear = this.getYear(b);
        if (aYear < bYear) {
            return -1;
        }
        if (aYear > bYear) {
            return 1;
        }
        if (granularity === ELuDateGranularity.year) {
            return 0;
        }
        const aMonth = this.getMonth(a);
        const bMonth = this.getMonth(b);
        if (aMonth < bMonth) {
            return -1;
        }
        if (aMonth > bMonth) {
            return 1;
        }
        if (granularity === ELuDateGranularity.month) {
            return 0;
        }
        const aDate = this.getDate(a);
        const bDate = this.getDate(b);
        if (aDate < bDate) {
            return -1;
        }
        if (aDate > bDate) {
            return 1;
        }
        if (granularity === ELuDateGranularity.day) {
            return 0;
        }
        return 0;
    }
}

const luDefaultNativeDateAdapterOptions = {
    useUtc: false,
};
const LU_NATIVE_DATE_ADAPTER_OPTIONS = new InjectionToken('Native date adapter options');

class LuNativeDateAdapter extends ALuDateAdapter {
    constructor(_locale, _options) {
        super();
        this._locale = _locale;
        this._options = _options;
        this._regex = /[/,.\-\s]/i;
        this._order = {
            date: 0,
            month: 1,
            year: 2,
        };
        this._options = this._options || luDefaultNativeDateAdapterOptions;
        this.initOrder();
    }
    initOrder() {
        const format = getLocaleDateFormat(this._locale, FormatWidth.Short);
        const groups = format.split(this._regex);
        groups.forEach((g, i) => {
            if (g.indexOf('d') !== -1) {
                this._order.date = i;
            }
            if (g.indexOf('M') !== -1) {
                this._order.month = i;
            }
            if (g.indexOf('y') !== -1) {
                this._order.year = i;
            }
        });
    }
    extract(text, granularity = ELuDateGranularity.day) {
        const groups = text.split(this._regex);
        let date = 1, month = 1, year = 1;
        switch (granularity) {
            case ELuDateGranularity.year:
                year = parseInt(groups[Math.max(this._order.year - 2, 0)], 10);
                break;
            case ELuDateGranularity.month:
                month = parseInt(groups[Math.max(this._order.month - 1, 0)], 10);
                year = parseInt(groups[Math.max(this._order.year - 1, 0)], 10) || new Date().getFullYear();
                break;
            case ELuDateGranularity.day:
            default:
                date = parseInt(groups[this._order.date], 10);
                month = parseInt(groups[this._order.month], 10);
                year = parseInt(groups[this._order.year], 10) || new Date().getFullYear();
        }
        return { date, month, year };
    }
    isParsable(text, granularity = ELuDateGranularity.day) {
        if (!text) {
            return false;
        }
        const groups = text.split(this._regex);
        const dayTextInvalid = granularity === ELuDateGranularity.day && groups.length !== 3;
        const monthTextInvalid = granularity === ELuDateGranularity.month && groups.length !== 2;
        const yearTextInvalid = granularity === ELuDateGranularity.year && groups.length !== 1;
        if (dayTextInvalid || monthTextInvalid || yearTextInvalid) {
            return false;
        }
        try {
            const { date, month, year } = this.extract(text, granularity);
            // When year is equal or greater than 10_000 ISO string goes from 2000-01-01 to +010000-01-01 which is not supported by backends
            if (year >= 10000) {
                return false;
            }
            let d;
            if (this._options.useUtc) {
                d = new Date(Date.UTC(year, month - 1, date));
            }
            else {
                d = new Date(year, month - 1, date);
            }
            // checking if its a valid date
            // https://stackoverflow.com/questions/1353684/detecting-an-invalid-date-date-instance-in-javascript
            if (!(d instanceof Date)) {
                return false;
            }
            if (isNaN(d.getTime())) {
                return false;
            }
            // d is a valid date, but
            // as i can write new Date(1234, 56, 78) and mr javascript accepts it
            // i check now that the generated date has the same year/month/date as what i entered
            if (this._options.useUtc) {
                if (d.getUTCFullYear() !== year) {
                    return false;
                }
                if (d.getUTCMonth() !== month - 1) {
                    return false;
                }
                if (d.getUTCDate() !== date) {
                    return false;
                }
            }
            else {
                if (d.getFullYear() !== year) {
                    return false;
                }
                if (d.getMonth() !== month - 1) {
                    return false;
                }
                if (d.getDate() !== date) {
                    return false;
                }
            }
            return true;
        }
        catch {
            return false;
        }
    }
    parse(text, granularity = ELuDateGranularity.day) {
        if (!text) {
            return undefined;
        }
        if (!this.isParsable(text, granularity)) {
            return this.forgeInvalid();
        }
        const { date, month, year } = this.extract(text, granularity);
        return this.forge(year, month, date);
    }
    format(d, format) {
        if (this._options.useUtc) {
            return formatDate(d, format, this._locale, 'UTC');
        }
        else {
            return formatDate(d, format, this._locale);
        }
    }
    forge(year, month, date) {
        if (this._options.useUtc) {
            return new Date(Date.UTC(year, month - 1, date)); // month-1 cuz 0 -> january
        }
        else {
            return new Date(year, month - 1, date); // month-1 cuz 0 -> january
        }
    }
    forgeToday() {
        if (this._options.useUtc) {
            const nonUTCToday = new Date();
            return new Date(Date.UTC(nonUTCToday.getFullYear(), nonUTCToday.getMonth(), nonUTCToday.getDate()));
        }
        else {
            const today = new Date();
            return new Date(today.getFullYear(), today.getMonth(), today.getDate());
        }
    }
    forgeInvalid() {
        return new Date('Invalid Date');
    }
    isValid(d) {
        if (!(d instanceof Date)) {
            return false;
        }
        if (isNaN(d.getTime())) {
            return false;
        }
        return true;
    }
    clone(d) {
        return new Date(d);
    }
    getYear(d) {
        if (this._options.useUtc) {
            return d.getUTCFullYear();
        }
        else {
            return d.getFullYear();
        }
    }
    getMonth(d) {
        if (this._options.useUtc) {
            return d.getUTCMonth() + 1;
        }
        else {
            return d.getMonth() + 1;
        }
    }
    getDate(d) {
        if (this._options.useUtc) {
            return d.getUTCDate();
        }
        else {
            return d.getDate();
        }
    }
    getDay(d) {
        if (this._options.useUtc) {
            return d.getUTCDay();
        }
        else {
            return d.getDay();
        }
    }
    add(d, count, granularity) {
        let year = this.getYear(d);
        let month = this.getMonth(d);
        let date = this.getDate(d);
        switch (granularity) {
            case ELuDateGranularity.decade:
                year += 10 * count;
                break;
            case ELuDateGranularity.year:
                year += count;
                break;
            case ELuDateGranularity.month:
                month += count;
                break;
            case ELuDateGranularity.day:
                date += count;
                break;
        }
        return this.forge(year, month, date);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.3", ngImport: i0, type: LuNativeDateAdapter, deps: [{ token: LOCALE_ID }, { token: LU_NATIVE_DATE_ADAPTER_OPTIONS, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.1.3", ngImport: i0, type: LuNativeDateAdapter }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.3", ngImport: i0, type: LuNativeDateAdapter, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [LOCALE_ID]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [LU_NATIVE_DATE_ADAPTER_OPTIONS]
                }, {
                    type: Optional
                }] }]; } });

/** bind to a string with iso 26001 format YYYY-MM-DD */
class LuStringDateAdapter extends ALuDateAdapter {
    constructor(_locale) {
        super();
        this._locale = _locale;
        this._nativeAdapter = new LuNativeDateAdapter(this._locale, {
            useUtc: true,
        });
    }
    forge(year, month, date) {
        return this.dateToString(this._nativeAdapter.forge(year, month, date));
    }
    forgeToday() {
        return this.dateToString(this._nativeAdapter.forgeToday());
    }
    forgeInvalid() {
        return 'Invalid Date';
    }
    isValid(d) {
        return this._nativeAdapter.isValid(this.stringToDate(d));
    }
    compare(a, b, granularity) {
        const da = this.stringToDate(a);
        const db = this.stringToDate(b);
        return this._nativeAdapter.compare(da, db, granularity);
    }
    isParsable(text) {
        return this._nativeAdapter.isParsable(text);
    }
    parse(text, granularity) {
        return this.dateToString(this._nativeAdapter.parse(text, granularity));
    }
    format(d, format) {
        return this._nativeAdapter.format(this.stringToDate(d), format);
    }
    clone(d) {
        return `${d}`;
    }
    getYear(d) {
        return this._nativeAdapter.getYear(this.stringToDate(d));
    }
    getMonth(d) {
        return this._nativeAdapter.getMonth(this.stringToDate(d));
    }
    getDate(d) {
        return this._nativeAdapter.getDate(this.stringToDate(d));
    }
    getDay(d) {
        return this._nativeAdapter.getDay(this.stringToDate(d));
    }
    add(d, count, granularity) {
        return this.dateToString(this._nativeAdapter.add(this.stringToDate(d), count, granularity));
    }
    stringToDate(s) {
        return new Date(`${s}T00:00:00Z`);
    }
    dateToString(d) {
        let result;
        if (d === undefined) {
            result = undefined;
        }
        else if (!this._nativeAdapter.isValid(d)) {
            result = this.forgeInvalid();
        }
        else {
            result = d.toISOString().substring(0, 10);
        }
        return result;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.3", ngImport: i0, type: LuStringDateAdapter, deps: [{ token: LOCALE_ID }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.1.3", ngImport: i0, type: LuStringDateAdapter }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.3", ngImport: i0, type: LuStringDateAdapter, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [LOCALE_ID]
                }] }]; } });

class ALuOnCloseSubscriber {
}

class ALuOnOpenSubscriber {
}

class ALuOnScrollBottomSubscriber {
}

function isSupportedLang(locale, translations) {
    return locale in translations;
}
function getIntl(translationsToken) {
    const locale = inject(LOCALE_ID);
    const translations = inject(translationsToken);
    if (isSupportedLang(locale, translations)) {
        return translations[locale];
    }
    const shortLocale = locale.substring(0, 2);
    if (isSupportedLang(shortLocale, translations)) {
        return translations[shortLocale];
    }
    return translations['en'];
}

const ID_LENGTH = 8;
const ID_BASE = 16;
function generateId() {
    return Array(ID_LENGTH)
        .fill(0)
        .map(() => Math.floor(Math.random() * ID_BASE).toString(ID_BASE))
        .join('');
}

class PortalDirective {
    constructor() {
        this.viewContainerRef = inject(ViewContainerRef);
        this.renderer = inject(Renderer2);
        this.templateRef = inject(TemplateRef);
        this.luPortal = null;
    }
    render() {
        this.viewContainerRef.clear();
        if (this.luPortal instanceof TemplateRef) {
            this.viewContainerRef.createEmbeddedView(this.luPortal);
        }
        else {
            const ref = this.viewContainerRef.createEmbeddedView(this.templateRef);
            const container = ref.rootNodes[0];
            const parent = container.parentElement;
            this.renderer.insertBefore(parent, document.createTextNode(this.luPortal), container);
        }
    }
    ngOnChanges(changes) {
        if (changes['luPortal']) {
            // If we're here, it means that either the template ref changed or the string changed,
            // meaning that we need to render again
            this.render();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.3", ngImport: i0, type: PortalDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.1.3", type: PortalDirective, isStandalone: true, selector: "[luPortal]", inputs: { luPortal: "luPortal" }, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.3", ngImport: i0, type: PortalDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[luPortal]',
                    standalone: true,
                }]
        }], propDecorators: { luPortal: [{
                type: Input,
                args: [{ required: true }]
            }] } });

// This directive exists to temporarily resolve a conflict in how directives work, see https://github.com/angular/angular/issues/52072
class NgClazz extends NgClass {
    constructor() {
        super(inject(IterableDiffers), inject(KeyValueDiffers), inject(ElementRef), inject(Renderer2));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.3", ngImport: i0, type: NgClazz, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.1.3", type: NgClazz, isStandalone: true, selector: "[ngClazz]", usesInheritance: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.3", ngImport: i0, type: NgClazz, decorators: [{
            type: Directive,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: '[ngClazz]',
                    standalone: true,
                }]
        }], ctorParameters: function () { return []; } });

/**
 * Generated bundle index. Do not edit.
 */

export { ALuDateAdapter, ALuOnCloseSubscriber, ALuOnOpenSubscriber, ALuOnScrollBottomSubscriber, ELuDateGranularity, LU_NATIVE_DATE_ADAPTER_OPTIONS, LuNativeDateAdapter, LuStringDateAdapter, NgClazz, PortalDirective, generateId, getIntl, luDefaultNativeDateAdapterOptions };
//# sourceMappingURL=lucca-front-ng-core.mjs.map
